---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "README-"
)
library(rrapply)
```

# rrapply: revisiting R-base rapply

<!-- badges: start -->
[![Build Status](https://travis-ci.org/JorisChau/rrapply.svg?branch=master)](https://travis-ci.org/JorisChau/rrapply)
<!-- badges: end -->

The rrapply-package contains a single function `rrapply`, providing an extended implementation of R-base's `rapply` function, which applies a function `f` to all elements of a nested list recursively. rrapply is implemented using R's native C API and for this reason requires no external R-package dependencies.

## Installation

```{r, eval = FALSE}
# Install the development version from GitHub:
# install.packages("devtools")
devtools::install_github("JorisChau/rrapply")
```

## Example usage

### List pruning

With base `rapply`, there is no convenient way to prune or filter list elements from the input list. The `rrapply` function adds an option `how = "prune"` to prune all list elements not subject to application of `f` from a nested list,

```{r}
## Nested list of renewable energy as a percentage of total energy consumption per country in 2016
data("renewable_energy_by_country")
## Subset values for countries and areas in Oceania
renewable_oceania <- renewable_energy_by_country[["World"]]["Oceania"]
str(renewable_oceania, list.len = 3, give.attr = FALSE)

## Drop all logical NA's while preserving list structure 
na_drop_oceania <- rrapply(
  renewable_oceania,
  f = function(x) x,
  classes = "numeric",
  how = "prune"
)
str(na_drop_oceania, list.len = 3, give.attr = FALSE)
```

Instead, use `how = "flatten"` to return a flattened unnested version of the pruned list,

```{r}
## Drop all logical NA's and return unnested list
na_drop_oceania2 <- rrapply(
  renewable_oceania,
  f = function(x) x,
  classes = "numeric",
  how = "flatten"
)
str(na_drop_oceania2, list.len = 10, give.attr = FALSE)
```

### Condition function

Base `rapply` allows to apply a function `f` to list elements of certain types or classes via the `classes` argument. `rrapply` generalizes this option via an additional `condition` argument, which accepts any function to use as a condition or predicate to apply `f` to a subset of list elements. 

```{r}
## Drop all NA elements using condition function
na_drop_oceania3 <- rrapply(
  renewable_oceania,
  condition = Negate(is.na),
  f = function(x) x,
  how = "prune"
)
str(na_drop_oceania3, list.len = 3, give.attr = FALSE)

## Filter all countries with values above 85%
renewable_energy_above_85 <- rrapply(
  renewable_energy_by_country,
  condition = function(x) x > 85,
  how = "prune"
)
str(renewable_energy_above_85, give.attr = FALSE)
```

### Special symbols `.xname` and `.xpos`

In base `rapply`, the `f` function only has access to the content of the list element under evaluation, and there is no convenient way to access its name or location in the nested list from inside the `f` function. `rrapply` allows the use the special symbols `.xname` and `.xpos` inside the `f` and `condition` function. `.xname` evaluates to the name of list element, and `.xpos` evaluates to the position of the element in the nested list structured as an integer vector.

```{r}
## Apply a function using the name of the node
renewable_oceania4 <- rrapply(
  renewable_oceania,
  f = function(x) sprintf("Renewable energy in %s: %.2f%%", .xname, x),
  condition = Negate(is.na),
  how = "flatten"
)
str(renewable_oceania4, list.len = 10)

## Extract values based on country names
renewable_benelux <- rrapply(
  renewable_energy_by_country,
  condition = function(x) .xname %in% c("Belgium", "Netherlands", "Luxembourg"),
  how = "prune"
)
str(renewable_benelux, give.attr = FALSE)

## Filter European countries with value above 50%
renewable_europe_above_50 <- rrapply(
  renewable_energy_by_country,
  condition = function(x) identical(head(.xpos, 2), c(1L, 5L)) & x > 50,
  how = "prune"
)
str(renewable_europe_above_50, give.attr = FALSE)

## Return position of Sweden in list
(xpos_sweden <- rrapply(
  renewable_energy_by_country,
  condition = function(x) identical(.xname, "Sweden"),
  f = function(x) .xpos,
  how = "flatten"
))
renewable_energy_by_country[[xpos_sweden$Sweden]]
```

### Using `rrapply` on data.frames

Base `rapply` recurses into all list-like objects. Since data.frames are list-like objects, `rapply` always descends into the individual columns of a data.frame. `rrapply` includes an additional `dfAsList` argument, which if `FALSE` does not treat a data.frame as a list and applies the `f` function to the data.frame as a whole instead of its individual columns. 

However, it can also be useful to exploit the property that a data.frame is a list-like object and use base `rapply` to apply a function `f` to data.frame columns of certain classes via the `classes` argument. Using the `condition` argument in `rrapply`, we can apply a function `f` to a subset of data.frame columns using a more general predicate function, 

```{r}
## Scale only Sepal columns in iris dataset
iris_standard_sepal <- rrapply(
  iris,
  condition = function(x) grepl("Sepal", .xname),
  f = scale
)
head(iris_standard_sepal)

## Scale and keep only numeric columns
iris_standard_transmute <- rrapply(
  iris,
  f = scale,
  classes = "numeric",
  how = "prune"
)
head(iris_standard_transmute)

## Summarize only numeric columns with how = "flatten"
iris_standard_summarize <- rrapply(
  iris,
  f = summary,
  classes = "numeric",
  how = "flatten"
)
iris_standard_summarize
```

For more details and examples on how to use the `rrapply` function see the accompanying vignette in the vignettes folder. 


