[{"path":"/articles/1-when-to-use-rrapply.html","id":"list-recursion-in-r","dir":"Articles","previous_headings":"","what":"List recursion in R","title":"Efficient list recursion with rrapply","text":"nested list outlines genealogy several famous mathematicians. list element contains additional \"given\" attribute mathematician’s given name. numeric values leaf elements total number descendants according Mathematics Genealogy Project June 2020. descendants available missing value present leaf node. Consider following exercise list recursion: Filter descendants ‘Leonhard Euler’ keeping original list structure replace missing values zero. possible (efficient) solution using recursion Recall() function: works, hardly kind code like write seemingly simple data exploration question. Moreover, code easy follow reason , makes time-consuming update modify future tasks. Another approach unnest list manageable (e.g. rectangular) format use specialized packages igraph data.tree make pruning modifying node entries straightforward. Note attention must paid correctly include node attributes transformed object node names unique given example. sensible approach extensive data analysis, ideally like keep list original format simple data exploration reduce number processing steps minimize possibility introducing mistakes code. recursive function makes use rapply(), member base-R apply-family functions, allows apply function recursively elements nested list decide returned result structured. familiar rapply() function might useful first read function documentation help(\"rapply\") check first section rrapply-package vignette (browseVignettes(package = \"rrapply\")). Although quite useful, rapply()-function always sufficiently flexible practice, e.g. pruning elements nested list (demonstrated ). rrapply() function attempt enhance update base rapply() make generally applicable context list recursion. rrapply() function builds native implementation base rapply() R’s C-interface reason requires external dependencies.","code":"students <- list(   Bernoulli = structure(list(     Bernoulli = structure(list(       Bernoulli = structure(1, given = \"Daniel\"),       Euler = structure(list(         Euler = structure(NA, given = \"Johann\"),         Lagrange = structure(list(           Fourier = structure(68679, given = \"Jean-Baptiste\"),            Plana = structure(NA, given = \"Giovanni\"),           Poisson = structure(113435, given = \"Simeon\")         ), given = \"Joseph\")       ), given = \"Leonhard\")     ), given = \"Johann\"),     Bernoulli = structure(NA, given = \"Nikolaus\")   ), given = \"Jacob\") )  str(students, give.attr = FALSE) prune_replace_Euler <- function(x) {   i <- 1   while(i <= length(x)) {     if(identical(names(x)[i], \"Euler\") & identical(attr(x[[i]], \"given\"), \"Leonhard\")) {       x[[i]] <- rapply(x[[i]], f = function(x) replace(x, is.na(x), 0), how = \"replace\")       i <- i + 1     } else {       if(is.list(x[[i]])) {         val <- Recall(x[[i]])         x[[i]] <- val         i <- i + !is.null(val)       } else {         x[[i]] <- NULL       }       if(all(sapply(x, is.null))) {         x <- NULL       }     }   }   return(x) }  str(prune_replace_Euler(students), give.attr = FALSE)"},{"path":"/articles/1-when-to-use-rrapply.html","id":"when-to-use-rrapply","dir":"Articles","previous_headings":"","what":"When to use rrapply()","title":"Efficient list recursion with rrapply","text":"illustration purposes, use datasets renewable_energy_by_country pokedex included rrapply-package. renewable_energy_by_country nested list containing shares renewable energy percentage total energy consumption per country 2016. data publicly available United Nations Open SDG Data Hub UNSD-SDG07. 249 countries areas structured based geographical location according United Nations M49 standard UNSD-M49 numeric values listed country percentages, data available value country NA. pokedex nested list containing various property values 151 original Pokémon. convenience, subset values countries areas Oceania renewable_energy_by_country,","code":"library(rrapply) data(\"renewable_energy_by_country\") renewable_oceania <- renewable_energy_by_country[[\"World\"]][\"Oceania\"] str(renewable_oceania, list.len = 3, give.attr = FALSE)"},{"path":"/articles/1-when-to-use-rrapply.html","id":"list-pruning-and-unnesting","dir":"Articles","previous_headings":"When to use rrapply()","what":"List pruning and unnesting","title":"Efficient list recursion with rrapply","text":"base rapply(), convenient way prune filter elements input list. rrapply() function adds option = \"prune\" prune list elements subject application function f nested list. original list structure retained, similar non-pruned versions = \"replace\" = \"list\". Using = \"prune\", can instance drop NA elements list preserving original list structure: Instead, set = \"flatten\" return flattened unnested version pruned list. efficient first returning pruned list = \"prune\" unlisting flattening list subsequent step. , use = \"melt\" return melted data.frame pruned list similar format reshape2::melt() applied nested list. rows melted data.frame contain node paths elements pruned list. \"value\" column contains values terminal nodes analogous flattened list returned = \"flatten\". names present sublist input list, = \"melt\" replaces names melted data.frame list element indices \"1\", \"2\", etc.: Nested lists containing repeated observations, pokedex, can unnested = \"bind\", expands binds repeated observations (.e. sublists) individual rows wide data.frame. similar format repeated application tidyr::unnest_wider() nested data.frame.","code":"## Drop all logical NA's while preserving list structure  na_drop_oceania <- rrapply(   renewable_oceania,   f = identity,   classes = \"numeric\",   how = \"prune\" ) str(na_drop_oceania, list.len = 3, give.attr = FALSE) ## Drop all logical NA's and return unnested list na_drop_oceania2 <- rrapply(   renewable_oceania,   f = identity,   classes = \"numeric\",   how = \"flatten\" ) head(na_drop_oceania2, n = 10) ## Drop all logical NA's and return melted data.frame na_drop_oceania3 <- rrapply(   renewable_oceania,   f = identity,   classes = \"numeric\",   how = \"melt\" ) head(na_drop_oceania3) ## Remove all names at L2  ## (skip this for now, these arguments are explained in the following sections) oceania_unnamed <- rrapply(   renewable_oceania,   classes = \"list\",   condition = function(x, .xname) .xname == \"Oceania\",   f = unname )  ## Drop all logical NA's and return melted data.frame na_drop_oceania4 <- rrapply(   oceania_unnamed,   f = identity,   classes = \"numeric\",   how = \"melt\" ) head(na_drop_oceania4) ## Nested list of Pokemon properties in Pokemon GO data(\"pokedex\")  str(pokedex, list.len = 3)  ## Unnest list as a wide data.frame pokedex_wide <- rrapply(pokedex, how = \"bind\")  head(pokedex_wide[, c(1:3, 5:10)], n = 5)"},{"path":"/articles/1-when-to-use-rrapply.html","id":"condition-function","dir":"Articles","previous_headings":"When to use rrapply()","what":"Condition function","title":"Efficient list recursion with rrapply","text":"Base rapply() allows apply function f list elements certain types classes via classes argument. rrapply() generalizes concept via condition argument, accepts principal argument function use condition predicate apply f subset list elements. Conceptually, f function applied leaf elements condition function exactly evaluates TRUE similar isTRUE(). condition argument missing, f applied leaf elements. combination = \"prune\", condition function provides additional flexibility selecting filtering elements nested list. Using condition argument, can update function call drop NA’s list better reflect purpose: interesting consider condition also defined using classes argument. instance, can filter countries values satisfy certain numeric condition: Remark: Note NA elements returned, condition function evaluate TRUE NA values. Also, f argument allowed missing, case function applied leaf elements. condition function generalization classes argument flexible control predicate, also possible use deflt argument together = \"list\" = \"unlist\" set default value leaf elements condition evaluate TRUE: consistent base rapply(), deflt argument can still used together = \"list\" = \"unlist\".","code":"## drop all NA elements using condition function na_drop_oceania3 <- rrapply(   renewable_oceania,   condition = Negate(is.na),   f = identity,   how = \"prune\" ) str(na_drop_oceania3, list.len = 3, give.attr = FALSE) ## filter all countries with values above 85% renewable_energy_above_85 <- rrapply(   renewable_energy_by_country,    condition = function(x) x > 85,    how = \"prune\" ) str(renewable_energy_above_85, give.attr = FALSE)  ## or by passing arguments to condition via ... renewable_energy_equal_0 <- rrapply(   renewable_energy_by_country,    condition = \"==\",    e2 = 0,    how = \"prune\" ) str(renewable_energy_equal_0, give.attr = FALSE) ## replace all NA elements by zero na_zero_oceania_list <- rrapply(   renewable_oceania,    condition = Negate(is.na),    deflt = 0,    how = \"list\" ) str(na_zero_oceania_list, list.len = 3, give.attr = FALSE)"},{"path":"/articles/1-when-to-use-rrapply.html","id":"using-the-----argument","dir":"Articles","previous_headings":"When to use rrapply() > Condition function","what":"Using the ... argument","title":"Efficient list recursion with rrapply","text":"first argument f always evaluates content leaf element f applied. arguments (besides special arguments .xname, .xpos, .xparents .xsiblings discussed ) independent node content can supplied via ... argument. Since rrapply() accepts function two arguments f condition, arguments defined via ... also need defined function arguments f condition function (existing), even used function . clarify, consider following example replace NA elements value defined separate argument newvalue:","code":"## this is not ok! tryCatch({   rrapply(     renewable_oceania,      condition = is.na,      f = function(x, newvalue) newvalue,      newvalue = 0,      how = \"replace\"   ) }, error = function(error) error$message)  ## this is ok na_zero_oceania_replace3 <- rrapply(   renewable_oceania,    condition = function(x, newvalue) is.na(x),    f = function(x, newvalue) newvalue,    newvalue = 0,    how = \"replace\" ) str(na_zero_oceania_replace3, list.len = 3, give.attr = FALSE)"},{"path":"/articles/1-when-to-use-rrapply.html","id":"special-arguments--xname--xpos--xparents-and--xsiblings","dir":"Articles","previous_headings":"When to use rrapply()","what":"Special arguments .xname, .xpos, .xparents and .xsiblings","title":"Efficient list recursion with rrapply","text":"base rapply(), f function access content list element evaluation principal argument, convenient way access name location nested list inside f function. makes rapply() impractical want apply function f relies e.g. name position node students example . overcome limitation, rrapply() allows use special arguments .xname, .xpos, .xparents .xsiblings inside f condition functions (addition principal function argument). .xname evaluates name list element, .xpos evaluates position element nested list structured integer vector, .xparents evaluates vector parent node names path current list element, .xsiblings evaluates parent list containing current list element direct siblings. Using .xname .xpos arguments, can transform filter list elements based names positions nested list: Knowing Europe located node renewable_energy_by_country[[c(1, 5)]], can filter European countries renewable energy share 50 percent using .xpos argument, can done conveniently using .xparents argument, require us look location Europe list beforehand, Using .xpos argument, look location particular country nested list, Instead, using .xsiblings argument look direct neighbors particular country nested list, also use .xpos argument determine maximum depth list length longest sublist follows, unnesting nested lists = \"bind\", .xname, .xpos .xparents arguments can useful parse particular set data.frame columns:","code":"## apply a function using the name of the node renewable_oceania_text <- rrapply(   renewable_oceania,   f = function(x, .xname) sprintf(\"Renewable energy in %s: %.2f%%\", .xname, x),   condition = Negate(is.na),   how = \"flatten\" ) head(renewable_oceania_text, n = 5)  ## extract values based on country names renewable_benelux <- rrapply(   renewable_energy_by_country,   condition = function(x, .xname) .xname %in% c(\"Belgium\", \"Netherlands\", \"Luxembourg\"),   how = \"prune\" ) str(renewable_benelux, give.attr = FALSE) ## filter European countries with value above 50% renewable_europe_above_50 <- rrapply(   renewable_energy_by_country,   condition = function(x, .xpos) identical(head(.xpos, 2), c(1L, 5L)) & x > 50,   how = \"prune\" ) str(renewable_europe_above_50, give.attr = FALSE) ## filter European countries with value above 50% renewable_europe_above_50 <- rrapply(   renewable_energy_by_country,   condition = function(x, .xparents) \"Europe\" %in% .xparents & x > 50,   how = \"prune\" ) str(renewable_europe_above_50, give.attr = FALSE) ## look up position of Sweden in list (xpos_sweden <- rrapply(   renewable_energy_by_country,   condition = function(x, .xname) identical(.xname, \"Sweden\"),   f = function(x, .xpos) .xpos,   how = \"flatten\" )) renewable_energy_by_country[[xpos_sweden$Sweden]] ## look up sibling countries of Sweden in list siblings_sweden <- rrapply(   renewable_energy_by_country,   condition = function(x, .xsiblings) \"Sweden\" %in% names(.xsiblings),   how = \"flatten\" ) head(siblings_sweden, n = 10) ## maximum list depth depth_all <- rrapply(   renewable_energy_by_country,    f = function(x, .xpos) length(.xpos),    how = \"unlist\" ) max(depth_all)   ## longest sublist length sublist_count <- rrapply(   renewable_energy_by_country,    f = function(x, .xpos) max(.xpos),    how = \"unlist\" ) max(sublist_count) ## parse only Pokemon number, name and type columns  pokedex_small <- rrapply(   pokedex,   condition = function(x, .xpos, .xname) {     length(.xpos) < 4 & .xname %in% c(\"num\", \"name\", \"type\")     },   how = \"bind\" )  head(pokedex_small)"},{"path":"/articles/1-when-to-use-rrapply.html","id":"avoid-recursing-into-list-nodes","dir":"Articles","previous_headings":"When to use rrapply()","what":"Avoid recursing into list nodes","title":"Efficient list recursion with rrapply","text":"default, classes = \"\" base rapply() rrapply() recurse list-like element. Using classes = \"list\" base rapply() effect function descends list node evaluating classes argument. contrast, rrapply() detect classes = \"list\", case f function applied list elements satisfy condition function. condition satisfied list element, rrapply() recurse sublist, apply f function nodes satisfy condition . use classes = \"list\" tells rrapply() descend list objects default. reason behavior can triggered classes argument use e.g. condition = .list. choice classes = \"list\" useful calculate summary statistics across nodes look position intermediate nodes nested list. illustrate, can return mean standard deviation renewable energy share Europe follows: Remark: Note principal x argument f function now evaluates list node satisfying condition. reason, first unlist sublist passing mean sd. can use .xpos argument apply f function specific locations depths nested list. instance, return mean renewable energy shares continent making use fact .xpos vector continent length (.e. depth) 2: classes = \"list\", f function applied (non-terminal) list nodes. classes = \"\", f function applied (terminal) non-list node. apply f terminal non-terminal node nested list, combine classes = c(\"list\", \"\"). illustrated searching terminal non-terminal nodes country region M49-code \"155\" (Western Europe): Another illustrating example preprocess certain list nodes unnesting nested list. , extract Pokémon evolutions pokedex without pre-processing Pokémon evolution list nodes:","code":"## compute mean value of Europe rrapply(   renewable_energy_by_country,     classes = \"list\",   condition = function(x, .xname) .xname == \"Europe\",   f = function(x) list(     mean = mean(unlist(x), na.rm = TRUE),      sd = sd(unlist(x), na.rm = TRUE)   ),   how = \"flatten\" ) ## compute mean value of each continent renewable_continent_summary <- rrapply(   renewable_energy_by_country,     classes = \"list\",   condition = function(x, .xpos) length(.xpos) == 2,   f = function(x) mean(unlist(x), na.rm = TRUE) )  ## Antarctica has a missing value str(renewable_continent_summary, give.attr = FALSE) ## Filter country or region by M49-code rrapply(   renewable_energy_by_country,   classes = c(\"list\", \"ANY\"),    condition = function(x) attr(x, \"M49-code\") == \"155\",   f = function(x, .xname) .xname,   how = \"unlist\" ) ## Pokemon evolution columns without pre-processing pokedex_wide1 <- rrapply(   pokedex,   condition = function(x, .xparents) any(grepl(\"name|evolution\", .xparents)),   how = \"bind\" )  head(pokedex_wide1, n = 3)  ## Pokemon evolution columns simplified to character vectors  pokedex_wide2 <- rrapply(   pokedex,   classes = c(\"character\", \"list\"),   condition = function(x, .xparents) any(grepl(\"name|evolution\", .xparents)),   f = function(x) if(is.list(x)) sapply(x, `[[`, \"name\") else x,   how = \"bind\" )      head(pokedex_wide2, n = 9)"},{"path":"/articles/1-when-to-use-rrapply.html","id":"recursive-list-node-modification","dir":"Articles","previous_headings":"When to use rrapply()","what":"Recursive list node modification","title":"Efficient list recursion with rrapply","text":"classes = \"list\", rrapply() applies f function list element satisfies condition function, recurse list elements. makes instance impossible recursively update name list element nested list, rrapply() stops recursing updating first list layer. purpose, set classes = \"list\" combined = \"recurse\", case rrapply() recurses updated list element application f function (using = \"replace\"). context, condition argument interpreted passing criterion: long condition classes arguments satisfied, rrapply() try recurse list-like element. Using = \"recurse\", can recursively replace names renewable_energy_by_country M49-codes: Remark: passed list(renewable_energy_by_country) call rrapply() order start application f function level list renewable_energy_by_country , instead starting list elements.","code":"## replace country names by M-49 codes renewable_M49 <- rrapply(   list(renewable_energy_by_country),    classes = \"list\",   f = function(x) {     names(x) <- vapply(x, attr, character(1L), which = \"M49-code\")     return(x)   },   how = \"recurse\" )  str(renewable_M49[[1]], max.level = 3, list.len = 3, give.attr = FALSE)"},{"path":[]},{"path":"/articles/1-when-to-use-rrapply.html","id":"avoid-recursing-into-data-frames","dir":"Articles","previous_headings":"When to use rrapply() > Miscellaneous","what":"Avoid recursing into data.frames","title":"Efficient list recursion with rrapply","text":"classes = \"\", rrapply() recurses list-like object equivalent base rapply(). Since data.frames list-like objects, f function applied individual columns instead data.frame object whole. avoid behavior, set classes = \"data.frame\", case f condition functions applied directly data.frame object columns. Note base rapply() using classes = \"data.frame\" effect rapply() descends columns data.frame object evaluating classes argument. Remark: Note result can also obtained using classes = \"list\" checking list element evaluation data.frame:","code":"## create a list of data.frames oceania_df <- list(   Oceania = lapply(     renewable_oceania[[\"Oceania\"]],      FUN = function(x) data.frame(       Name = names(x),        value = unlist(x),        stringsAsFactors = FALSE     )   ) )  ## this does not work! tryCatch({   rrapply(     oceania_df,     f = function(x) subset(x, !is.na(value)), ## filter NA-rows of data.frame     how = \"replace\"   ) }, error = function(error) error$message)  ## this does work rrapply(   oceania_df,   classes = \"data.frame\",   f = function(x) subset(x, !is.na(value)),   how = \"replace\" ) rrapply(   oceania_df,   classes = \"list\",   condition = is.data.frame,   f = function(x) subset(x, !is.na(value)),   how = \"replace\" )"},{"path":"/articles/1-when-to-use-rrapply.html","id":"list-attributes","dir":"Articles","previous_headings":"When to use rrapply() > Miscellaneous > Avoid recursing into data.frames","what":"List attributes","title":"Efficient list recursion with rrapply","text":"Base rapply() may produce different results using = \"replace\" = \"list\" working list attributes. former preserves intermediate list attributes whereas latter . avoid unexpected behavior, rrapply() always preserves intermediate list attributes using = \"replace\", = \"list\" = \"prune\". = \"flatten\", = \"melt\", = \"bind\" = \"unlist\" intermediate list attributes preserved result longer nested list.","code":"## how = \"list\" now preserves all list attributes na_drop_oceania_list_attr2 <- rrapply(   renewable_oceania,    f = function(x) replace(x, is.na(x), 0),    how = \"list\" )  str(na_drop_oceania_list_attr2, max.level = 2)  ## how = \"prune\" also preserves list attributes na_drop_oceania_attr <- rrapply(   renewable_oceania,    condition = Negate(is.na),    how = \"prune\" ) str(na_drop_oceania_attr, max.level = 2)"},{"path":"/articles/1-when-to-use-rrapply.html","id":"using-rrapply-on-data-frames","dir":"Articles","previous_headings":"When to use rrapply() > Miscellaneous","what":"Using rrapply() on data.frames","title":"Efficient list recursion with rrapply","text":"previous sections explained avoid recursing list-like elements using rrapply(). However, can also useful exploit property data.frame list-like object use base rapply() apply function f data.frame columns certain classes. instance, straightforward standardize numeric columns iris dataset sample mean standard deviation: Using condition argument rrapply(), gain additional flexibility selecting columns f applied. instance, can apply f function Sepal columns using .xname argument: Instead mutating columns, can also transmute columns (.e. keeping columns f applied) setting = \"prune\": order summarize set selected columns, use = \"flatten\" instead = \"prune\", latter preserves list attributes –including data.frame dimensions– kept.","code":"iris_standard <- rapply(iris, f = scale, classes = \"numeric\", how = \"replace\") head(iris_standard) iris_standard_sepal <- rrapply(   iris,                       condition = function(x, .xname) grepl(\"Sepal\", .xname),    f = scale ) head(iris_standard_sepal) iris_standard_transmute <- rrapply(   iris,    f = scale,    classes = \"numeric\",    how = \"prune\" ) head(iris_standard_transmute) ## summarize columns with how = \"flatten\" iris_standard_summarize <- rrapply(   iris,    f = summary,    classes = \"numeric\",    how = \"flatten\" ) iris_standard_summarize"},{"path":"/articles/1-when-to-use-rrapply.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Efficient list recursion with rrapply","text":"conclude, let us return list recursion exercise first section. Using rrapply(), can solve task readable less error-prone fashion. possible approach split question two steps follows: Knowing Johann Euler descendant Leonhard Euler, can simplify single function call using .xparents argument: additional information details check package vignette (browseVignettes(package = \"rrapply\")) articles Articles section.","code":"## look up the position of Euler (Leonhard) xpos_Euler <- rrapply(   students,    classes = \"list\",   condition = function(x, .xname) .xname == \"Euler\" && attr(x, \"given\") == \"Leonhard\",   f = function(x, .xpos) .xpos,   how = \"flatten\" )[[1]]  xpos_Euler   ## filter descendants of Euler (Leonhard) and replace missing values by zero students_Euler <- rrapply(   students,   condition = function(x, .xpos) identical(.xpos[seq_along(xpos_Euler)], xpos_Euler),    f = function(x) replace(x, is.na(x), 0),   how = \"prune\" )  str(students_Euler, give.attr = FALSE) ## filter descendants of Euler (Leonhard) and replace missing values by zero students_Euler <- rrapply(   students,   condition = function(x, .xparents) \"Euler\" %in% .xparents,   f = function(x) replace(x, is.na(x), 0),   how = \"prune\" )  str(students_Euler, give.attr = FALSE)"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"efficient-list-unnesting","dir":"Articles","previous_headings":"","what":"Efficient list unnesting","title":"Efficient list melting and unnesting with rrapply","text":"tutorial vignette(\"1---use-rrapply\") describes use rrapply() applied directly data formatted nested list. specific reason keep data form nested list, often practical transform nested list manageable rectangular format execute data processing steps unnested object (e.g. data.frame). purpose, rrapply() includes options = \"melt\" = \"bind\" unnest nested list either long wide data.frame. following sections explain two options detail provide several examples usage.","code":""},{"path":"/articles/2-efficient-melting-unnesting.html","id":"unnest-to-long-data-frame-with-how-melt","dir":"Articles","previous_headings":"Efficient list unnesting","what":"Unnest to long data.frame with how = \"melt\"","title":"Efficient list melting and unnesting with rrapply","text":"option = \"melt\" unnests nested list long melted data.frame similar format reshape2::melt() applied nested list. rows melted data.frame contain individual node paths elements nested list pruning (based condition classes arguments). \"value\" column vector- list-column values terminal nodes identical result returned = \"flatten\", see also vignette(\"1---use-rrapply\"). comparison reshape2::melt(), rrapply() provides additional flexibility filter transform specific list elements melting nested list using e.g. f, classes condition arguments. importantly, rrapply() optimized specifically nested lists, whereas reshape2::melt() mainly aimed melting data.frames superseded tidyr::gather() recent tidyr::pivot_longer(). reason, reshape2::melt() tends quite slow applied larger nested lists. illustration purposes, use dataset renewable_energy_by_country vignette(\"1---use-rrapply\"), nested list containing per country shares renewable energy percentage total energy consumption 2016. First, let us convert nested list melted data.frame: data processing reshaping data.frames familiar R territory, subsequent processing tasks likely straightforward execute using melted data.frame using original nested list. instance, can easily filter Western European countries subset() (using e.g. dplyr data.table): completeness, note similar result can also obtained directly rrapply() using .xparents argument: , L5 column longer present pruned list contain elements depth melting long data.frame. Now let us return results reshape2::melt(), rrapply() orders columns differently default \"value\" column might follow slightly different coercion rules, data contained melted data.frame identical. medium-sized list used , computational speed reshape2::melt() acceptable practical usage. However, computational efficiency quickly decreases melting larger deeply nested lists: Although unlikely encounter large deeply nested lists practice, artificial examples serve illustrate reshape2::melt() well-suited convert large nested lists melted data.frames.","code":"library(rrapply) data(\"renewable_energy_by_country\") system.time(   renewable_energy_melt <- rrapply(renewable_energy_by_country, how = \"melt\") )  head(renewable_energy_melt, 10) renewable_energy_melt_west_eu <- subset(renewable_energy_melt, L3 == \"Western Europe\")  renewable_energy_melt_west_eu rrapply(   renewable_energy_by_country,    condition = function(x, .xparents) \"Western Europe\" %in% .xparents,   how = \"melt\" ) system.time(   renewable_energy_melt_reshape2 <- reshape2::melt(renewable_energy_by_country) ) head(renewable_energy_melt_reshape2, 10) ## helper function to generate named nested list new_list <- function(n, dmax, d = 0, name = NULL) {   x <- vector(mode = \"list\", length = n)   names(x) <- if(!is.null(name)) paste(name, seq_len(n), sep = \".\") else seq_len(n)   for(i in seq_len(n)) {     if(d + 1 < dmax) {       x[[i]] <- Recall(n, dmax, d + 1, paste(c(name, i), collapse = \".\"))     } else {       x[[i]] <- 1L     }   }   return(x) }  ## generate a large shallow list with 3 layers and a total of 10^6 elements shallow_list <- new_list(n = 100, dmax = 3) str(shallow_list, list.len = 2)  ## benchmark timing with rrapply system.time(shallow_melt <- rrapply(shallow_list, how = \"melt\"))  head(shallow_melt)  ## benchmark timing with reshape2::melt system.time(shallow_melt_reshape2 <- reshape2::melt(shallow_list)) head(shallow_melt_reshape2) ## generate a deeply nested list with 18 layers and a total of 2^18 elements deep_list <- new_list(n = 2, dmax = 18) str(deep_list, max.level = 3)  ## benchmark timing with rrapply system.time(deep_melt <- rrapply(deep_list, how = \"melt\"))   ## benchmark timing with reshape2::melt system.time(deep_melt_reshape2 <- reshape2::melt(deep_list))"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"unnest-to-wide-data-frame-with-how-bind","dir":"Articles","previous_headings":"Efficient list unnesting","what":"Unnest to wide data.frame with how = \"bind\"","title":"Efficient list melting and unnesting with rrapply","text":"option = \"bind\" unnests nested list wide data.frame useful unnest nested lists containing repeated observations variables. Consider instance pokedex dataset vignette(\"1---use-rrapply\"), nested list containing 17 property variables 151 original Pokémon. Setting = \"bind\" unnests pokedex list wide data.frame single row entry Pokémon: Pokémon sublist flattened single wide row data.frame. 151 rows stacked aligned matching variable names, missing variables replaced NAs (similar data.table::rbindlist(..., fill = TRUE)). Note nested variables, next_evolution prev_evolution, unnested individual data.frame columns similar repeated application tidyr::unnest_wider() data.frame nested list-columns. Remark: discovery repeated observations (e.g. individual Pokémon) based depth first search nested list. Conceptually, nested list traversed detect multi-element sublists without names name repeated list element. sublist detected, elements flattened row-binded wide data.frame.","code":"data(\"pokedex\")  ## all 151 Pokemon entries str(pokedex, list.len = 3)  ## single Pokemon entry str(pokedex[[\"pokemon\"]][[1]]) pokedex_wide <- rrapply(pokedex, how = \"bind\")  ## display few data.frame columns head(pokedex_wide[, c(1:3, 5:10)], n = 5)  ## display all data.frame columns str(pokedex_wide, max.level = 1, vec.len = 1)"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"comparison-to-common-alternatives","dir":"Articles","previous_headings":"Efficient list unnesting > Unnest to wide data.frame with how = \"bind\"","what":"Comparison to common alternatives","title":"Efficient list melting and unnesting with rrapply","text":"Several common alternatives unnest lists containing repeated observations also eluded previous section include data.table::rbindlist(), dplyr::bind_rows(), tidyr’s dedicated rectangling functions unnest_longer(), unnest_wider() hoist(). first two functions useful lists repeated data.frames (lists) containing levels nesting (e.g. data.frames without list-columns): rectangling functions tidyr-package offer lot flexibility. similar result rrapply(pokedex, = \"bind\") can obtained : option = \"bind\" rrapply() arguably less flexible always expands nested list data.frame wide possible. hand, increased flexibility interpretability tidyr’s rectangling functions come cost computational efficiency, can quickly become bottleneck unnesting large nested lists: Note chained calls unnest_wider() unnest first layer list-columns next_evolution prev_evolution, resulting children list-columns, increase computation time. Remark: following approach simultaneously unnest nested list post-process resulting data.frame columns particularly efficient: reason condition f functions applied node nested list individually vectorized way, makes call time-consuming. likely efficient post-process data.frame outside call rrapply(), e.g. using data.table:","code":"## bind_rows() works fine with simple lists  pokedex_wide_dplyr <- dplyr::bind_rows(lapply(pokedex[[\"pokemon\"]], `[`, 1:4)) head(pokedex_wide_dplyr)  ## but does not work well with list-columns tryCatch(dplyr::bind_rows(lapply(pokedex[[\"pokemon\"]], `[`, 1:5)), error = function(err) err$message)    ## rbindlist() works fine with simple lists  pokedex_wide_dt <- data.table::rbindlist(lapply(pokedex[[\"pokemon\"]], `[`, 1:4))   head(pokedex_wide_dt)  ## but is not ideal for nested variables pokedex_wide_dt2 <- data.table::rbindlist(lapply(pokedex[[\"pokemon\"]], `[`, c(\"name\", \"prev_evolution\")), fill = TRUE) head(pokedex_wide_dt2) library(tidyr) library(tibble)  pokedex_wide_tidyr <- as_tibble(pokedex) %>%   unnest_wider(pokemon) %>%   unnest_wider(next_evolution, names_sep = \".\") %>%   unnest_wider(prev_evolution, names_sep = \".\") %>%   unnest_wider(next_evolution.1, names_sep = \".\") %>%   unnest_wider(next_evolution.2, names_sep = \".\") %>%   unnest_wider(next_evolution.3, names_sep = \".\") %>%   unnest_wider(prev_evolution.1, names_sep = \".\") %>%   unnest_wider(prev_evolution.2, names_sep = \".\")   pokedex_wide_tidyr ## replicate the original pokedex 1000 times pokedex_large <- list(pokemon = do.call(c, replicate(1E3, pokedex[[\"pokemon\"]], simplify = FALSE)))  system.time({   rrapply(pokedex_large, how = \"bind\") })  ## unnest only first layer of next_evolution and prev_evolution system.time({   as_tibble(pokedex_large) %>%     unnest_wider(pokemon) %>%     unnest_wider(next_evolution, names_sep = \".\") %>%     unnest_wider(prev_evolution, names_sep = \".\")  }) ## Combine Pokemon evolution names in single call system.time({   pokedex_large_evolutions <- rrapply(     pokedex_large,     classes = c(\"character\", \"list\"),     condition = function(x, .xparents) any(grepl(\"name|evolution\", .xparents)),     f = function(x) if(is.list(x)) sapply(x, `[[`, \"name\") else x,     how = \"bind\"   ) })  head(pokedex_large_evolutions, n = 9) library(data.table, quietly = TRUE)  ## Combine Pokemon evolution names in multiple calls system.time({   pokedex_large_evolutions2 <- as.data.table(rrapply(pokedex_large, how = \"bind\"))   pokedex_large_evolutions2[, pokemon.next_evolution := as.list(transpose(.SD)), .SDcols = patterns(\"next_evolution.*name\")]   pokedex_large_evolutions2[, pokemon.prev_evolution := as.list(transpose(.SD)), .SDcols = patterns(\"prev_evolution.*name\")] })  head(pokedex_large_evolutions2[, .(pokemon.name, pokemon.next_evolution, pokemon.prev_evolution)])"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"additional-examples","dir":"Articles","previous_headings":"Efficient list unnesting > Unnest to wide data.frame with how = \"bind\"","what":"Additional examples","title":"Efficient list melting and unnesting with rrapply","text":"conclude section replicating demonstrating examples tidyr vignette https://tidyr.tidyverse.org/articles/rectangle.html. nested list datasets publicly available repurrrsive-package.","code":"library(repurrrsive)  ## github users dataset str(gh_users, list.len = 3)  ## return all variables in result gh_users_wide <- rrapply(gh_users, how = \"bind\")  head(gh_users_wide[, c(\"login\", \"followers\", \"url\", \"html_url\")])  ## github repos dataset str(gh_repos, list.len = 2)  ## return only a subset of variables gh_repos_wide <- rrapply(   unlist(gh_repos, recursive = FALSE),   condition = function(x, .xname) .xname %in% c(\"login\", \"name\", \"homepage\", \"watchers_count\"),   how = \"bind\" )  head(gh_repos_wide)  ## GoT characters dataset str(got_chars, list.len = 3)  ## return only list-columns got_chars_wide <- rrapply(got_chars, how = \"bind\") got_chars_wide <- rrapply(got_chars_wide, classes = \"list\", how = \"prune\")  head(as_tibble(got_chars_wide))"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"efficient-unmelting-of-melted-data-frames","dir":"Articles","previous_headings":"","what":"Efficient unmelting of melted data.frames","title":"Efficient list melting and unnesting with rrapply","text":"Let’s return example melted long data.frame first section containing renewable energy shares Western European countries: Suppose data.frame needs converted back nested list object order write JSON- XML-object, perhaps tree visualization purpose. Writing recursive function restore nested list can prove quite time-consuming error-prone task. Base R’s unlist() function inverse function relist(), relist() requires skeleton nested list repopulate, skeleton clearly unavailable current context. particular, since filtered entries melted data.frame, can longer use original list template object, without filtering nodes original list well. purpose, rrapply() includes additional option = \"unmelt\" performs inverse operation = \"melt\". skeleton object needed case, ordinary data.frame format returned = \"melt\". illustrate, can convert melted data.frame nested list follows: Remark 1: = \"unmelt\" based greedy approach parsing data.frame rows list elements starting top data.frame. , rrapply() continues collecting children nodes long parent node name remains unchanged. , instance, wish create two separate nodes (level) name \"Western Europe\", nodes listed one another melted data.frame rrapply() group children single \"Western Europe\" list element. Remark 2: Internally, = \"unmelt\" reconstructs nested list melted data.frame subsequently follows conceptual framework = \"replace\". function arguments, f condition therefore used exactly way one use = \"replace\" applied nested list object. Remark 3: = \"unmelt\" (currently) restore attributes intermediate list nodes therefore exact inverse = \"melt\". way around always produce results: terms computational effort, rrapply()’s = \"unmelt\" can equally efficient base R’s relist() even though template list object can repopulated. illustrated using large list objects generated :","code":"renewable_energy_melt_west_eu renewable_energy_west_eu_unmelt <- rrapply(renewable_energy_melt_west_eu, how = \"unmelt\") str(renewable_energy_west_eu_unmelt, give.attr = FALSE) renewable_energy_unmelt <- rrapply(renewable_energy_melt, how = \"unmelt\") renewable_energy_remelt <- rrapply(renewable_energy_unmelt, how = \"melt\")  identical(renewable_energy_melt, renewable_energy_remelt) ## deeply nested list with 18 layers and a total of 2^18 elements ## benchmark timing with rrapply how = \"unmelt\" system.time(deep_unmelt <- rrapply(deep_melt, how = \"unmelt\"))  identical(deep_unmelt, deep_list)  ## benchmark timing with relist deep_unlist <- unlist(as.relistable(deep_list)) system.time(deep_relist <- relist(deep_unlist)) ## large shallow list with 3 layers and a total of 10^6 elements ## benchmark timing with rrapply how = \"unmelt\" system.time(shallow_unmelt <- rrapply(shallow_melt, how = \"unmelt\"))  identical(shallow_unmelt, shallow_list)  ## benchmark timing with relist shallow_unlist <- unlist(as.relistable(shallow_list)) system.time(shallow_relist <- relist(shallow_unlist))"},{"path":"/articles/3-calls-and-expressions.html","id":"expressions","dir":"Articles","previous_headings":"","what":"Expressions","title":"Recursive apply for call and expression objects","text":"Unevaluated R code always parsed captured set expressions, collective term used refer following types objects: scalar constants e.g. TRUE 1, symbols e.g. quote(x), call objects e.g. quote(x <- 1), expression vectors e.g. expression(<- 1, 2 * b) pairlists e.g. formals(seq.default). Call objects expression vectors hierarchically structured objects (also called abstract syntax trees) can decomposed symbols scalar constants atomic building blocks. introduction expressions abstract syntax trees, see also chapter https://adv-r.hadley.nz/expressions.html. Call objects expression vectors generally behave nested lists, e.g. subsetting call object works subsetting nested list. illustrate, can retrieve abstract syntax tree call object recursing object way nested list: Given information, might expect base rapply() also recurses call objects expression vectors way nested lists, unfortunately case. precise, rapply() accept expression vectors input, effectively treats flat lists call objects similar lapply(). Call objects accepted rapply() return error.","code":"## recurse through call as nested list ast <- function(expr) {   lapply(expr, function(x) {     if(is.call(x) || is.expression(x)) {       ast(x)      } else {       x     }   }) }  ## decompose call object str(ast(quote(y <- x <- 1 + TRUE))) ## rapply on an expression vector rapply(expression(y <- x <- 1, f(g(2 * pi))), f = identity)  ## lapply on an expression vector lapply(expression(y <- x <- 1, f(g(2 * pi))), FUN = identity)  ## rapply on a call object (not ok!)  tryCatch({   rapply(quote(y <- x <- 1), f = identity) }, error = function(error) error$message)"},{"path":"/articles/3-calls-and-expressions.html","id":"expressions-and-rrapply","dir":"Articles","previous_headings":"","what":"Expressions and rrapply()","title":"Recursive apply for call and expression objects","text":"Starting version 1.2.0 rrapply() also supports recursion call objects expression vectors, treated nested lists based internal abstract syntax trees. , functionality described vignette(\"1---use-rrapply\") extends directly call objects expression vectors.","code":""},{"path":"/articles/3-calls-and-expressions.html","id":"structuring-the-result","dir":"Articles","previous_headings":"Expressions and rrapply()","what":"Structuring the result","title":"Recursive apply for call and expression objects","text":"applying rrapply() (base rapply()) nested lists difference = \"replace\" = \"list\" relatively minor. choices return nested list, = \"list\" replaces elements subject f argument deflt. call objects expression objects, difference important = \"replace\" always maintains type object application rrapply(), whereas = \"list\" returns object formatted nested list. = \"replace\", can instance directly update abstract syntax tree call object: Using = \"list\", can update abstract syntax tree return nested list: Remark: Note second function call use classes = \"logical\" avoid list elements class \"logical\" replaced deflt argument (NULL). choices = \"prune\", = \"flatten\" = \"melt\" return pruned abstract syntax tree : nested list, flattened vector list melted data.frame respectively. identical application rrapply() abstract syntax tree formatted nested list. illustrate, let us return names abstract syntax tree expression vector part base R.","code":"library(rrapply)  call_old <- quote(y <- x <- 1 + TRUE) str(call_old)  ## update call object call_new <- rrapply(call_old, classes = \"logical\", f = as.numeric, how = \"replace\") str(call_new) ## update and decompose call object call_ast <- rrapply(call_old, f = function(x) ifelse(is.logical(x), as.numeric(x), x), how = \"list\") str(call_ast) ## example expression expr <- expression(y <- x <- 1, f(g(2 * pi))) ## check if name is not in base environment is_new_name <- function(x) !exists(as.character(x), envir = baseenv())  ## prune and decompose expression expr_prune <- rrapply(expr, classes = \"name\", condition = is_new_name, how = \"prune\") str(expr_prune)  ## prune and flatten expression expr_flatten <- rrapply(expr, classes = \"name\", condition = is_new_name, how = \"flatten\") str(expr_flatten)  ## prune and melt expression expr_melt <- rrapply(expr, classes = \"name\", condition = is_new_name, how = \"melt\") expr_melt"},{"path":"/articles/3-calls-and-expressions.html","id":"avoid-recursing-into-expression-nodes","dir":"Articles","previous_headings":"Expressions and rrapply()","what":"Avoid recursing into expression nodes","title":"Recursive apply for call and expression objects","text":"classes = \"\" (default), rrapply() recurses list-like element, expression objects : call objects, expression vectors pairlists. avoid recursing list elements nested list, can use classes = \"list\". Analogously, avoid recursing list-like elements abstract syntax tree, use classes = \"language\", classes = \"expression\", classes = \"pairlist\" combination thereof. condition classes arguments satisfied given list-like element, rrapply() recurse object, apply f function nodes satisfy condition classes . Note behavior can triggered classes argument use e.g. condition = .call. illustrate, extract deeply nested call objects example expression return flat list:","code":"## extract all terminal call nodes of AST rrapply(   expr,    classes = \"language\",    condition = function(x) !any(sapply(x, is.call)),   how = \"flatten\" )"},{"path":"/articles/3-calls-and-expressions.html","id":"additional-code-examples","dir":"Articles","previous_headings":"Expressions and rrapply()","what":"Additional code examples","title":"Recursive apply for call and expression objects","text":"section provides several worked code examples using rrapply() recurse abstract syntax tree call object, mainly inspired codetools package chapter https://adv-r.hadley.nz/expressions.html#ast-funs. Note examples can also rewritten using recursive function definitions base R, use rrapply() makes code quite concise straightforward follow. examples ordered increasing degrees code complexity.","code":""},{"path":"/articles/3-calls-and-expressions.html","id":"example-1-replacing-t-and-f","dir":"Articles","previous_headings":"Expressions and rrapply() > Additional code examples","what":"Example 1: Replacing T and F","title":"Recursive apply for call and expression objects","text":"https://adv-r.hadley.nz/expressions.html#ast-funs, demonstrate recursion abstract syntax tree expression, recursive function logical_abbr() defined check presence logical abbreviations T F expression object: Let us revisit example find, also replace logical abbreviations non-abbreviated counterparts. Using rrapply(), set = \"replace\" order maintain original object type updating abstract syntax tree:","code":"## recursive function to check for T or F logical_abbr <- function(x) {   if (is.atomic(x)) {     FALSE   } else if (is.name(x)) {     identical(x, quote(T)) || identical(x, quote(F))   } else if (is.call(x) || is.pairlist(x)) {     for (i in seq_along(x)) {       if (logical_abbr(x[[i]])) return(TRUE)     }     FALSE   } else {     stop(\"Don't know how to handle type \", typeof(x),           call. = FALSE)   } }  call1 <- quote(mean(x, na.rm = T)) call2 <- quote(f(x = c(TRUE, FALSE)))  ## containing a logical abbreviation logical_abbr(call1) ## not containing a logical abbreviation logical_abbr(call2) ## expand logical abbreviation logical_abbr_expand <- function(x) {   if(identical(x, quote(T))) {     TRUE   } else if(identical(x, quote(F))) {     FALSE   } else {     x   } }  call3 <- expression(f(x = c(T, F)), any(T, FALSE))  rrapply(call1, f = logical_abbr_expand, how = \"replace\") rrapply(call3, f = logical_abbr_expand, how = \"replace\")"},{"path":"/articles/3-calls-and-expressions.html","id":"example-2-finding-local-variables","dir":"Articles","previous_headings":"Expressions and rrapply() > Additional code examples","what":"Example 2: Finding local variables","title":"Recursive apply for call and expression objects","text":"second demonstrating example abstract syntax tree recursion https://adv-r.hadley.nz/expressions.html#ast-funs deals finding variables expression created assignment. recursive function find_assign() finds variables created assignment <- returns character vector: Revisiting example using rrapply(), essentially need filter name (.e. symbol) second element call <-. Checking position element call can done .xpos argument. verify first element call actual assignment, can make use .xsiblings argument. slightly generalize find_assign() function also return variables created =, , assign delayedAssign.","code":"find_assign <- function(x) {   if (is.atomic(x) || is.name(x)) {     character()   } else if (is.call(x)) {     if (identical(x[[1]], quote(`<-`)) && is.name(x[[2]])) {       lhs <- as.character(x[[2]])     } else {       lhs <- character()     }     unique(c(lhs, unlist(lapply(x, find_assign))))   } else if (is.pairlist(x)) {     unique(unlist(lapply(x, find_assign)))   } else {     stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)   } }  call4 <- quote({   l <- list()   l$a <- 5   names(l) <- \"b\" })  find_assign(call4) ## helper function to check if variable is created by assignment is_assign <- function(x, .xpos, .xsiblings) {   ## element is second in call   identical(.xpos[length(.xpos)], 2L) &&     ## first element in call is assignment     as.character(.xsiblings[[1]]) %in% c(\"<-\", \"=\", \"for\", \"assign\", \"delayedAssign\") }  rrapply(call4, condition = is_assign, f = as.character, how = \"unlist\")"},{"path":"/articles/3-calls-and-expressions.html","id":"example-3-finding-global-variables","dir":"Articles","previous_headings":"Expressions and rrapply() > Additional code examples","what":"Example 3: Finding global variables","title":"Recursive apply for call and expression objects","text":"codetools package contains findGlobals() find global variables used function. Building previous example, can construct (simplified) version findGlobals() searching variable body function local variable function argument. precisely, collect variable names global variables character vector exclude. includes: function arguments; variables created assignment previous example; package names used :: ::: (e.g. stats stats::lm()); variable names used $ @ (e.g. x$list x@S4-object). recurse abstract syntax tree similar previous example discarding variable names elements exclude part base environment (.e. baseenv()). remaining global variables returned character vector. Remark: sake simplicity, completely rigorous example. instance, function arguments inline functions excluded set global variables. Also, variable names created assign() delayedAssign() assigned e.g. .GlobalEnv, case arguably recognized global variables. illustrate newly defined function find_globals(), let us apply rrapply() function : C_unmelt() C_rrapply() internal workhorses rrapply() part rrapply-package. default, codetools findGlobals() function also returns variable names base package. Discarding names present base package findGlobals() produces result find_globals(): Several additional comparisons find_globals() findGlobals2() applied common R functions:","code":"## helper function to check for non-global variables is_exclude <-function(x, .xpos, .xsiblings) {   (identical(.xpos[length(.xpos)], 2L) &&      as.character(.xsiblings[[1]]) %in% c(\"<-\", \"=\", \"for\", \"assign\", \"delayedAssign\", \"::\", \":::\")) ||     (identical(.xpos[length(.xpos)], 3L) &&        as.character(.xsiblings[[1]]) %in% c(\"@\", \"$\")) }  ## helper function to check for global variables is_global <- function(x, exclude) {   !is.null(x) &&     nzchar(as.character(x)) &&     !as.character(x) %in% exclude &&     !exists(as.character(x), envir = baseenv()) }  find_globals <- function(fun) {   ## find variables to exclude   exclude <- rrapply(body(fun), condition = is_exclude, f = as.character, how = \"unlist\")   exclude <- c(names(formals(fun)), exclude)   ## find global variables                globals <- rrapply(body(fun), classes = \"name\", condition = is_global, f = as.character, exclude = exclude, how = \"unlist\")   return(unique(globals)) } find_globals(rrapply) ## update existing findGlobals function findGlobals2 <- function(fun, merge = TRUE) {   globals <- codetools::findGlobals(fun, merge = merge)   globals[sapply(globals, Negate(exists), envir = baseenv())] }  findGlobals2(rrapply) ## par is part of formals(plot.default) find_globals(plot.default) findGlobals2(plot.default)  ## model.frame is present as stats::model.frame find_globals(lm) findGlobals2(lm)  ## parallel functions are present as parallel::... find_globals(boot::boot) findGlobals2(boot::boot)"},{"path":"/articles/3-calls-and-expressions.html","id":"example-4-plot-abstract-syntax-tree-as-dendrogram","dir":"Articles","previous_headings":"Expressions and rrapply() > Additional code examples","what":"Example 4: Plot abstract syntax tree as dendrogram","title":"Recursive apply for call and expression objects","text":"conclude, let us consider plotting abstract syntax trees dendrograms. Base R includes plot() method dendrogram objects, therefore suffices write function allows convert expression objects dendrogram objects. turns dendrogram object defined nested list specific attributes list component turn dendrogram. seen previously, can convert abstract syntax tree expression object nested list rrapply() setting = \"list\". addition, need recurse nested list add dendrogram specific attributes. achieve single node, define separate helper function add_dend_attrs() distinguishes branch (.e. list) nodes leaf nodes abstract syntax tree. height attribute add_dend_attrs() calculated function depth node evaluation overall maximum depth abstract syntax tree. first can obtained via special argument .xpos, second evaluated recursing abstract syntax tree call rrapply(). apply add_dend_attrs() (terminal non-terminal) node nested list, set classes = c(\"list\", \"\") = \"recurse\" second call rrapply() explained vignette(\"1---use-rrapply\"). test defined function, provide call object body rrapply() function pass expr_to_dend() convert dendrogram:","code":"## helper function to add dendrogram attributes add_dend_attrs <- function(x, .xpos, maxdepth) {   if(is.list(x)) {     x <- rev(x)     members <- length(unlist(x))     attributes(x) <- list(       members = members,        midpoints = members - 1     )   } else {     x <- ifelse(!is.null(x), as.character(x), \"NULL\")     attributes(x) <- list(       label = x,        members = 1,        leaf = TRUE     )   }   attr(x, \"height\") <- 1 + (1 - length(.xpos)) / maxdepth   return(x) }  ## convert expression to dendrogram expr_to_dend <- function(expr) {   maxdepth <- integer(1)   dend1 <- rrapply(expr, f = function(x, .xpos) { if(length(.xpos) > maxdepth) maxdepth <<- length(.xpos); x }, how = \"list\")   dend2 <- rrapply(list(dend1), classes = c(\"list\", \"ANY\"), f = add_dend_attrs, maxdepth = maxdepth, how = \"recurse\")[[1]]   class(dend2) <- \"dendrogram\"   return(dend2) } ## plot abstract syntax tree as dendrogram  (rrapply_dend <- expr_to_dend(body(rrapply))) plot(rrapply_dend, horiz = TRUE, type = \"triangle\", yaxt = \"n\")"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joris Chau. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chau J (2022). rrapply: Revisiting Base Rapply. https://jorischau.github.io/rrapply/, https://github.com/JorisChau/rrapply.","code":"@Manual{,   title = {rrapply: Revisiting Base Rapply},   author = {Joris Chau},   year = {2022},   note = {https://jorischau.github.io/rrapply/, https://github.com/JorisChau/rrapply}, }"},{"path":"/index.html","id":"rrapply-revisiting-r-base-rapply-","dir":"","previous_headings":"","what":"Revisiting Base Rapply","title":"Revisiting Base Rapply","text":"minimal {rrapply}-package contains single function rrapply(), providing extended implementation R-base’s rapply() function, applies function f elements nested list recursively controls structure returned result. rrapply() builds upon rapply()’s native C implementation reason requires external R-package dependencies.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Revisiting Base Rapply","text":"","code":"# Install latest release from CRAN: install.packages(\"rrapply\")  # Install the development version from GitHub: # install.packages(\"devtools\") devtools::install_github(\"JorisChau/rrapply\")"},{"path":[]},{"path":[]},{"path":[]},{"path":"/index.html","id":"-how--prune","dir":"","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"• how = \"prune\"","title":"Revisiting Base Rapply","text":"base rapply(), convenient way prune filter list elements input list object. rrapply() function adds option = \"prune\" prune list elements subject application f nested list,","code":"library(rrapply)  ## data: renewable energy per country in 2016 (% of total energy consumption) data(\"renewable_energy_by_country\")  ## subset countries and areas in Oceania renewable_oceania <- renewable_energy_by_country[[\"World\"]][\"Oceania\"] str(renewable_oceania, list.len = 3, give.attr = FALSE)  #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : logi NA #>   .. ..$ Cocos (Keeling) Islands          : logi NA #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated] ## drop all logical NA's while preserving list structure  rrapply(   renewable_oceania,   f = \\(x) x,   classes = \"numeric\",   how = \"prune\" ) |>   str(list.len = 3, give.attr = FALSE)  #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/index.html","id":"-how--flatten","dir":"","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"• how = \"flatten\"","title":"Revisiting Base Rapply","text":"Instead, use = \"flatten\" return flattened unnested version pruned list, Hint: options argument allows avoid coercion flattened list vector /include parent list names result.","code":"## drop all logical NA's and return unnested list rrapply(   renewable_oceania,   f = \\(x) x,   classes = \"numeric\",   how = \"flatten\" ) |>   head(n = 10)  #>        Australia      New Zealand             Fiji    New Caledonia  #>             9.32            32.76            24.36             4.03  #> Papua New Guinea  Solomon Islands          Vanuatu             Guam  #>            50.34            65.73            33.67             3.03  #>         Kiribati Marshall Islands  #>            45.43            11.75 ## flatten to simple list with full names rrapply(   renewable_oceania,   f = \\(x) x,   classes = \"numeric\",   how = \"flatten\",   options = list(namesep = \".\", simplify = FALSE) ) |>   str(list.len = 5, give.attr = FALSE)  #> List of 29 #>  $ Oceania.Australia and New Zealand.Australia        : num 9.32 #>  $ Oceania.Australia and New Zealand.New Zealand      : num 32.8 #>  $ Oceania.Melanesia.Fiji                             : num 24.4 #>  $ Oceania.Melanesia.New Caledonia                    : num 4.03 #>  $ Oceania.Melanesia.Papua New Guinea                 : num 50.3 #>   [list output truncated]"},{"path":"/index.html","id":"-how--melt","dir":"","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"• how = \"melt\"","title":"Revisiting Base Rapply","text":", use = \"melt\" return melted data.frame pruned list similar format reshape2::melt() applied nested list. melted data.frame can used reconstruct nested list = \"unmelt\",","code":"## drop all logical NA's and return melted data.frame oceania_melt <- rrapply(   renewable_oceania,   f = \\(x) x,   classes = \"numeric\",   how = \"melt\" ) head(oceania_melt)  #>        L1                        L2               L3 value #> 1 Oceania Australia and New Zealand        Australia  9.32 #> 2 Oceania Australia and New Zealand      New Zealand 32.76 #> 3 Oceania                 Melanesia             Fiji 24.36 #> 4 Oceania                 Melanesia    New Caledonia  4.03 #> 5 Oceania                 Melanesia Papua New Guinea 50.34 #> 6 Oceania                 Melanesia  Solomon Islands 65.73 ## reconstruct nested list from melted data.frame rrapply(oceania_melt, how = \"unmelt\") |>   str(list.len = 3, give.attr = FALSE)  #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/index.html","id":"-how--bind","dir":"","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"• how = \"bind\"","title":"Revisiting Base Rapply","text":"Nested lists containing repeated observations can unnested = \"bind\", returns wide data.frame similar format dplyr::bind_rows() applied list data.frames repeated application tidyr::unnest_wider() nested data.frame. Hint: set options = list(namecols = TRUE) include parent list names associated row wide data.frame individual columns L1, L2, etc.","code":"## data: nested list of Pokemon properties in Pokemon GO data(\"pokedex\") str(pokedex, list.len = 3)  #> List of 1 #>  $ pokemon:List of 151 #>   ..$ :List of 16 #>   .. ..$ id            : int 1 #>   .. ..$ num           : chr \"001\" #>   .. ..$ name          : chr \"Bulbasaur\" #>   .. .. [list output truncated] #>   ..$ :List of 17 #>   .. ..$ id            : int 2 #>   .. ..$ num           : chr \"002\" #>   .. ..$ name          : chr \"Ivysaur\" #>   .. .. [list output truncated] #>   ..$ :List of 15 #>   .. ..$ id            : int 3 #>   .. ..$ num           : chr \"003\" #>   .. ..$ name          : chr \"Venusaur\" #>   .. .. [list output truncated] #>   .. [list output truncated] ## unnest list to wide data.frame rrapply(pokedex, how = \"bind\")[, c(1:3, 5:8)] |>   head(n = 9)  #>   id num       name          type height   weight            candy #> 1  1 001  Bulbasaur Grass, Poison 0.71 m   6.9 kg  Bulbasaur Candy #> 2  2 002    Ivysaur Grass, Poison 0.99 m  13.0 kg  Bulbasaur Candy #> 3  3 003   Venusaur Grass, Poison 2.01 m 100.0 kg  Bulbasaur Candy #> 4  4 004 Charmander          Fire 0.61 m   8.5 kg Charmander Candy #> 5  5 005 Charmeleon          Fire 1.09 m  19.0 kg Charmander Candy #> 6  6 006  Charizard  Fire, Flying 1.70 m  90.5 kg Charmander Candy #> 7  7 007   Squirtle         Water 0.51 m   9.0 kg   Squirtle Candy #> 8  8 008  Wartortle         Water 0.99 m  22.5 kg   Squirtle Candy #> 9  9 009  Blastoise         Water 1.60 m  85.5 kg   Squirtle Candy ## bind to data.frame including parent columns rrapply(pokedex, how = \"bind\", options = list(namecols = TRUE))[, c(1:5, 7:10)] |>   head(n = 6)  #>        L1 L2 id num       name          type height   weight            candy #> 1 pokemon  1  1 001  Bulbasaur Grass, Poison 0.71 m   6.9 kg  Bulbasaur Candy #> 2 pokemon  2  2 002    Ivysaur Grass, Poison 0.99 m  13.0 kg  Bulbasaur Candy #> 3 pokemon  3  3 003   Venusaur Grass, Poison 2.01 m 100.0 kg  Bulbasaur Candy #> 4 pokemon  4  4 004 Charmander          Fire 0.61 m   8.5 kg Charmander Candy #> 5 pokemon  5  5 005 Charmeleon          Fire 1.09 m  19.0 kg Charmander Candy #> 6 pokemon  6  6 006  Charizard  Fire, Flying 1.70 m  90.5 kg Charmander Candy"},{"path":"/index.html","id":"condition-function","dir":"","previous_headings":"When to use rrapply()","what":"Condition function","title":"Revisiting Base Rapply","text":"Base rapply() allows apply function f list elements certain types classes via classes argument. rrapply() generalizes option via additional condition argument, accepts function use condition predicate apply f subset list elements.","code":"## drop all NA elements using condition  rrapply(   renewable_oceania,   condition = \\(x) !is.na(x),   f = \\(x) x,   how = \"prune\" ) |>   str(list.len = 3, give.attr = FALSE)  #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated] ## filter all countries with values > 85% rrapply(   renewable_energy_by_country,   condition = \\(x) x > 85,   how = \"prune\" ) |>   str(give.attr = FALSE)  #> List of 1 #>  $ World:List of 1 #>   ..$ Africa:List of 1 #>   .. ..$ Sub-Saharan Africa:List of 3 #>   .. .. ..$ Eastern Africa:List of 7 #>   .. .. .. ..$ Burundi                    : num 89.2 #>   .. .. .. ..$ Ethiopia                   : num 91.9 #>   .. .. .. ..$ Rwanda                     : num 86 #>   .. .. .. ..$ Somalia                    : num 94.7 #>   .. .. .. ..$ Uganda                     : num 88.6 #>   .. .. .. ..$ United Republic of Tanzania: num 86.1 #>   .. .. .. ..$ Zambia                     : num 88.5 #>   .. .. ..$ Middle Africa :List of 2 #>   .. .. .. ..$ Chad                            : num 85.3 #>   .. .. .. ..$ Democratic Republic of the Congo: num 97 #>   .. .. ..$ Western Africa:List of 1 #>   .. .. .. ..$ Guinea-Bissau: num 86.5"},{"path":"/index.html","id":"special-arguments-xname-xpos-xparents-and-xsiblings","dir":"","previous_headings":"When to use rrapply()","what":"Special arguments .xname, .xpos, .xparents and .xsiblings","title":"Revisiting Base Rapply","text":"base rapply(), f function access content list element evaluation, convenient way access name location nested list inside f. rrapply() defines special arguments .xname, .xpos, .xparents, .xsiblings inside f condition functions (addition principal function argument): .xname evaluates name list element; .xpos evaluates position element nested list structured integer vector; .xparents evaluates vector parent list names path current list element; .xsiblings evaluates parent list containing current list element direct siblings.","code":"## apply f based on element's name rrapply(   renewable_oceania,   condition = \\(x) !is.na(x),   f = \\(x, .xname) sprintf(\"Renewable energy in %s: %.2f%%\", .xname, x),   how = \"flatten\" ) |>   head(n = 5)  #>                                      Australia  #>         \"Renewable energy in Australia: 9.32%\"  #>                                    New Zealand  #>      \"Renewable energy in New Zealand: 32.76%\"  #>                                           Fiji  #>             \"Renewable energy in Fiji: 24.36%\"  #>                                  New Caledonia  #>     \"Renewable energy in New Caledonia: 4.03%\"  #>                               Papua New Guinea  #> \"Renewable energy in Papua New Guinea: 50.34%\"  ## filter elements by name  rrapply(   renewable_energy_by_country,   condition = \\(x, .xname) .xname %in% c(\"Belgium\", \"Netherlands\", \"Luxembourg\"),   how = \"prune\" ) |>   str(give.attr = FALSE)  #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 1 #>   .. ..$ Western Europe:List of 3 #>   .. .. ..$ Belgium    : num 9.14 #>   .. .. ..$ Luxembourg : num 13.5 #>   .. .. ..$ Netherlands: num 5.78  ## filter European countries > 50% using .xpos rrapply(   renewable_energy_by_country,   condition = \\(x, .xpos) identical(.xpos[1:2], c(1L, 5L)) && x > 50,   how = \"prune\" ) |>   str(give.attr = FALSE)  #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 2 #>   .. ..$ Northern Europe:List of 3 #>   .. .. ..$ Iceland: num 78.1 #>   .. .. ..$ Norway : num 59.5 #>   .. .. ..$ Sweden : num 51.4 #>   .. ..$ Western Europe :List of 1 #>   .. .. ..$ Liechtenstein: num 62.9  ## filter European countries > 50% using .xparents rrapply(   renewable_energy_by_country,    condition = \\(x, .xparents) \"Europe\" %in% .xparents && x > 50,   how = \"prune\" ) |>   str(give.attr = FALSE)  #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 2 #>   .. ..$ Northern Europe:List of 3 #>   .. .. ..$ Iceland: num 78.1 #>   .. .. ..$ Norway : num 59.5 #>   .. .. ..$ Sweden : num 51.4 #>   .. ..$ Western Europe :List of 1 #>   .. .. ..$ Liechtenstein: num 62.9  ## return position of element in list rrapply(   renewable_energy_by_country,   condition = \\(x, .xname) .xname == \"Sweden\",   f = \\(x, .xpos) .xpos,   how = \"flatten\" )  #> $Sweden #> [1]  1  5  2 14  ## return siblings of element in list rrapply(   renewable_energy_by_country,   condition = \\(x, .xsiblings) \"Sweden\" %in% names(.xsiblings),   how = \"flatten\" ) |>   head(n = 5)  #> Aland Islands       Denmark       Estonia Faroe Islands       Finland  #>            NA         33.06         26.55          4.24         42.03  ## filter elements and unnest list   rrapply(   pokedex,   condition = \\(x, .xpos, .xname) length(.xpos) < 4 & .xname %in% c(\"num\", \"name\", \"type\"),   how = \"bind\" ) |>   head()  #>   num       name          type #> 1 001  Bulbasaur Grass, Poison #> 2 002    Ivysaur Grass, Poison #> 3 003   Venusaur Grass, Poison #> 4 004 Charmander          Fire #> 5 005 Charmeleon          Fire #> 6 006  Charizard  Fire, Flying"},{"path":"/index.html","id":"modifying-list-elements","dir":"","previous_headings":"When to use rrapply()","what":"Modifying list elements","title":"Revisiting Base Rapply","text":"default, base rapply() rrapply() recurse “list-like” element. Set classes = \"list\" rrapply() override apply f list element (.e. sublist) satisfies condition argument. can useful e.g. collapse sublists calculate summary statistics across elements nested list: Hint: data.frames also list-like objects, rrapply() applies f individual data.frame columns default. Set classes = \"data.frame\" avoid behavior apply f condition functions complete data.frame objects instead individual data.frame columns.","code":"## calculate mean value of Europe rrapply(   renewable_energy_by_country,     condition = \\(x, .xname) .xname == \"Europe\",   f = \\(x) mean(unlist(x), na.rm = TRUE),   classes = \"list\",   how = \"flatten\" )  #>   Europe  #> 22.36565  ## calculate mean value for each continent ## (Antartica's value is missing) rrapply(   renewable_energy_by_country,    condition = \\(x, .xpos) length(.xpos) == 2,   f = \\(x) mean(unlist(x), na.rm = TRUE),   classes = \"list\" ) |>   str(give.attr = FALSE)  #> List of 1 #>  $ World:List of 6 #>   ..$ Africa    : num 54.3 #>   ..$ Americas  : num 18.2 #>   ..$ Antarctica: logi NA #>   ..$ Asia      : num 17.9 #>   ..$ Europe    : num 22.4 #>   ..$ Oceania   : num 17.8  ## simplify pokemon evolutions to character vectors  rrapply(   pokedex,   condition = \\(x, .xname) .xname %in% c(\"name\", \"next_evolution\", \"prev_evolution\"),    f = \\(x) if(is.list(x)) sapply(x, `[[`, \"name\") else x,   classes = c(\"character\", \"list\"),   how = \"bind\" ) |>   head(n = 9)  #>         name        next_evolution         prev_evolution #> 1  Bulbasaur     Ivysaur, Venusaur                     NA #> 2    Ivysaur              Venusaur              Bulbasaur #> 3   Venusaur                    NA     Bulbasaur, Ivysaur #> 4 Charmander Charmeleon, Charizard                     NA #> 5 Charmeleon             Charizard             Charmander #> 6  Charizard                    NA Charmander, Charmeleon #> 7   Squirtle  Wartortle, Blastoise                     NA #> 8  Wartortle             Blastoise               Squirtle #> 9  Blastoise                    NA    Squirtle, Wartortle"},{"path":[]},{"path":"/index.html","id":"-how--recurse","dir":"","previous_headings":"When to use rrapply() > Recursive list updating","what":"• how = \"recurse\"","title":"Revisiting Base Rapply","text":"classes = \"list\" = \"recurse\", rrapply() applies f function list element satisfies condition argument similar previous section, recurses updated list-like element application f. can useful e.g. recursively update class attributes elements nested list:","code":"## recursively remove all list attributes rrapply(   renewable_oceania,   f = \\(x) c(x),   classes = c(\"list\", \"ANY\"),   how = \"recurse\" ) |>   str(list.len = 3, give.attr = TRUE)  #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : logi NA #>   .. ..$ Cocos (Keeling) Islands          : logi NA #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/index.html","id":"-how--names","dir":"","previous_headings":"When to use rrapply() > Recursive list updating","what":"• how = \"names\"","title":"Revisiting Base Rapply","text":"option = \"names\" special case = \"recurse\", value f used replace name evaluated list element instead content (options). default, = \"names\" uses classes = c(\"list\", \"\") order allow updating names nested list.","code":"## recursively replace all names by M49-codes rrapply(   renewable_oceania,   f = \\(x) attr(x, \"M49-code\"),   how = \"names\" ) |>   str(list.len = 3, give.attr = FALSE)  #> List of 1 #>  $ 009:List of 4 #>   ..$ 053:List of 6 #>   .. ..$ 036: num 9.32 #>   .. ..$ 162: logi NA #>   .. ..$ 166: logi NA #>   .. .. [list output truncated] #>   ..$ 054:List of 5 #>   .. ..$ 242: num 24.4 #>   .. ..$ 540: num 4.03 #>   .. ..$ 598: num 50.3 #>   .. .. [list output truncated] #>   ..$ 057:List of 8 #>   .. ..$ 316: num 3.03 #>   .. ..$ 296: num 45.4 #>   .. ..$ 584: num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/index.html","id":"expression-objects","dir":"","previous_headings":"When to use rrapply()","what":"Expression objects","title":"Revisiting Base Rapply","text":"Base rapply() include recursion expression objects. contrast rrapply() supports recursion call objects expression vectors, treated nested lists based abstract syntax trees. , functionality applies nested lists extends directly call objects expression vectors. update abstract syntax tree call object, use = \"replace\": update abstract syntax tree return nested list, use = \"list\": modes = \"prune\", = \"flatten\" = \"melt\" return pruned abstract syntax tree : nested list, flattened list melted data.frame respectively. identical application rrapply() abstract syntax tree formatted nested list. illustrate, return names (.e. symbols) abstract syntax tree part base R: details examples use rrapply() function see accompanying package vignette vignettes folder Articles section https://jorischau.github.io/rrapply/.","code":"## language object (lang <- quote(y <- x <- 1 + TRUE))  #> y <- x <- 1 + TRUE  ## replace logicals by integers  rrapply(lang, classes = \"logical\", f = as.numeric, how = \"replace\")  #> y <- x <- 1 + 1 ## update and decompose call object rrapply(lang, f = function(x) ifelse(is.logical(x), as.numeric(x), x), how = \"list\") |>   str()  #> List of 3 #>  $ : symbol <- #>  $ : symbol y #>  $ :List of 3 #>   ..$ : symbol <- #>   ..$ : symbol x #>   ..$ :List of 3 #>   .. ..$ : symbol + #>   .. ..$ : num 1 #>   .. ..$ : num 1 ## expression vector expr <- expression(y <- x <- 1, f(g(2 * pi))) is_new_name <- function(x) !exists(as.character(x), envir = baseenv())  ## prune and decompose expression rrapply(expr, classes = \"name\", condition = is_new_name, how = \"prune\") |>   str()  #> List of 2 #>  $ :List of 2 #>   ..$ : symbol y #>   ..$ :List of 1 #>   .. ..$ : symbol x #>  $ :List of 2 #>   ..$ : symbol f #>   ..$ :List of 1 #>   .. ..$ : symbol g  ## prune and flatten expression rrapply(expr, classes = \"name\", condition = is_new_name, how = \"flatten\") |>   str()  #> List of 4 #>  $ : symbol y #>  $ : symbol x #>  $ : symbol f #>  $ : symbol g  ## prune and melt expression rrapply(expr, classes = \"name\", condition = is_new_name, f = as.character, how = \"melt\")  #>   L1 L2   L3 value #> 1  1  2 <NA>     y #> 2  1  3    2     x #> 3  2  1 <NA>     f #> 4  2  2    1     g"},{"path":"/reference/pokedex.html","id":null,"dir":"Reference","previous_headings":"","what":"Pokedex of Pokemon GO — pokedex","title":"Pokedex of Pokemon GO — pokedex","text":"nested list containing property values original 151 Pokemon present Pokemon GO. data available JSON format GitHub (credits Gianluca Bonifazi).","code":""},{"path":"/reference/pokedex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pokedex of Pokemon GO — pokedex","text":"","code":"pokedex"},{"path":"/reference/pokedex.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Pokedex of Pokemon GO — pokedex","text":"nested list containing 151 sublists 17 list elements: id integer, Identification number num character, Pokemon number official Pokedex name character, Pokemon name img character, URL png image Pokemon type character, Pokemon type height character, Pokemon height weight character, Pokemon weight candy character, type candy used evolve Pokemon given transfered candy_count integer, amount candies required evolve egg character, travel distance hatch egg spawn_change numeric, spawn change percentage avg_spawns integer, number spawns per 10.000 spawns spawn_time character, local time spawns active multipliers numeric, multiplier Combat Power (CP) evolution weakness character, types Pokemon Pokemon weak next_evolution list, numbers (num) names (name) successive evolutions prev_evolution list, numbers (num) names (name) previous evolutions","code":""},{"path":"/reference/pokedex.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Pokedex of Pokemon GO — pokedex","text":"PokemonGO-Pokedex","code":""},{"path":"/reference/renewable_energy_by_country.html","id":null,"dir":"Reference","previous_headings":"","what":"UNSD renewable energy share by country in 2016 — renewable_energy_by_country","title":"UNSD renewable energy share by country in 2016 — renewable_energy_by_country","text":"nested list containing renewable energy shares percentage total energy consumption per country 2016. dataset publicly available United Nations Open SDG Data Hub.","code":""},{"path":"/reference/renewable_energy_by_country.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UNSD renewable energy share by country in 2016 — renewable_energy_by_country","text":"","code":"renewable_energy_by_country"},{"path":"/reference/renewable_energy_by_country.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"UNSD renewable energy share by country in 2016 — renewable_energy_by_country","text":"249 countries areas structured nested list based geographical location  according United Nations M49 Standard (UNSD-M49).  numeric values listed country area percentages, data available value NA. list element contains \"M49-code\" attribute UN Standard Country Area Codes Statistical Use (Series M, . 49).","code":""},{"path":"/reference/renewable_energy_by_country.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"UNSD renewable energy share by country in 2016 — renewable_energy_by_country","text":"UNSD_SDG07","code":""},{"path":"/reference/rrapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Reimplementation of base-R's rapply — rrapply","title":"Reimplementation of base-R's rapply — rrapply","text":"rrapply reimplemented extended version rapply recursively apply function f  set elements list deciding result structured.","code":""},{"path":"/reference/rrapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reimplementation of base-R's rapply — rrapply","text":"","code":"rrapply(   object,   condition,   f,   classes = \"ANY\",   deflt = NULL,   how = c(\"replace\", \"list\", \"unlist\", \"prune\", \"flatten\", \"melt\", \"bind\", \"recurse\",     \"unmelt\", \"names\"),   options,   ... )"},{"path":"/reference/rrapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reimplementation of base-R's rapply — rrapply","text":"object list, expression vector, call object, .e., “list-like”. condition condition function one “principal” argument optional special arguments .xname, .xpos,  .xparents /.xsiblings (see ‘Details’), passing arguments via .... f function one “principal” argument optional special arguments .xname, .xpos, .xparents  /.xsiblings (see ‘Details’), passing arguments via .... classes character vector class names, \"\" match class terminal node. Include \"list\" \"data.frame\" match class non-terminal nodes well. deflt default result (used = \"list\" = \"unlist\"). character string partially matching ten possibilities given: see ‘Details’. options named list additional options namesep, simplify, namecols /coldepth  apply certain choices : see ‘Details’. ... additional arguments passed call f condition.","code":""},{"path":"/reference/rrapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reimplementation of base-R's rapply — rrapply","text":"= \"unlist\", vector rapply. = \"list\", = \"replace\", = \"recurse\" = \"names\",  “list-like” similar structure object rapply. = \"prune\", pruned “list-like” object  similar structure object pruned list elements based classes condition. = \"flatten\", flattened pruned vector list pruned elements based classes condition. = \"melt\", melted data.frame containing node paths  values pruned list elements based classes condition. = \"bind\", wide data.frame repeated list elements expanded single data.frame rows aligned identical list names using coercion rules = \"unlist\". repeated list elements  subject pruning based classes condition. = \"unmelt\", nested list list names values defined  data.frame object.","code":""},{"path":"/reference/rrapply.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Reimplementation of base-R's rapply — rrapply","text":"rrapply allows f function argument missing, case function applied list  elements. = \"unmelt\" requires input data.frame returned = \"melt\" character columns name nested list components final list- vector-column containing values nested list elements.","code":""},{"path":"/reference/rrapply.html","id":"how-to-structure-result","dir":"Reference","previous_headings":"","what":"How to structure result","title":"Reimplementation of base-R's rapply — rrapply","text":"addition rapply's modes set equal \"replace\", \"list\" \"unlist\",  seven choices \"prune\", \"flatten\", \"melt\", \"bind\", \"unmelt\", \"recurse\"  \"names\" available: = \"prune\" filters list elements subject application f list object. original  list structure retained, similar non-pruned options = \"replace\" = \"list\". = \"flatten\" efficient way return flattened unnested version pruned list. default = \"flatten\"  uses similar coercion rules = \"unlist\", can disabled simplify = FALSE options argument. = \"melt\" returns melted data.frame pruned list, row contains path single  terminal node pruned list depth layers L1, L2, . column \"value\" contains  possibly coerced values terminal nodes equivalent result = \"flatten\". list names present,  node names data.frame default indices list elements \"1\", \"2\", etc. = \"bind\" used unnest nested list containing repeated sublists wide data.frame. repeated sublist expanded  single row data.frame identical sublist component names aligned individual columns. default, list layer  containing repeated sublists identified based minimal depth detected across leaf nodes, can set manually coldepth  options argument. = \"unmelt\" special case reconstructs nested list melted data.frame. reason, = \"unmelt\"  applies data.frames format returned = \"melt\". Internally, = \"unmelt\" first reconstructs  nested list melted data.frame second uses functional framework = \"replace\". = \"recurse\" specialized option useful combination e.g. classes = \"list\" recurse  updated “list-like” elements. explained detail . = \"names\" modifies names nested list elements instead list content. = \"names\" internally works    = \"replace\", except value f used replace name list element consideration  instead content.","code":""},{"path":"/reference/rrapply.html","id":"condition-function","dir":"Reference","previous_headings":"","what":"Condition function","title":"Reimplementation of base-R's rapply — rrapply","text":"rapply rrapply allow apply f list elements certain classes via classes argument.  rrapply generalizes concept via additional condition argument, accepts function use condition  predicate select list elements f applied. Conceptually, f function applied list elements  condition function exactly evaluates TRUE similar isTRUE. condition function missing,  f applied list elements. Since condition function generalizes classes argument, allowed use deflt argument  together = \"list\" = \"unlist\" set default value list elements condition  evaluate TRUE.","code":""},{"path":"/reference/rrapply.html","id":"correct-use-of-","dir":"Reference","previous_headings":"","what":"Correct use of ...","title":"Reimplementation of base-R's rapply — rrapply","text":"principal argument f condition functions evaluates content list element. arguments  f condition (besides special arguments .xname, .xpos, etc. discussed ) supplied via dots ...  argument need defined function arguments f condition function (existing), even  used function . See also ‘Examples’ section.","code":""},{"path":"/reference/rrapply.html","id":"special-arguments-xname-xpos-xparents-and-xsiblings","dir":"Reference","previous_headings":"","what":"Special arguments .xname, .xpos, .xparents and .xsiblings","title":"Reimplementation of base-R's rapply — rrapply","text":"f condition functions accept four special arguments .xname, .xpos, .xparents .xsiblings addition first principal argument. .xname argument evaluates name list element. .xpos argument evaluates  position element nested list structured integer vector. , x = list(list(\"y\", \"z\")), .xpos  location c(1, 2) corresponds list element x[[c(1, 2)]]. .xparents argument evaluates vector parent  node names path list element. .xsiblings argument evaluates complete (sub)list includes list element direct child. names .xname, .xpos, .xparents .xsiblings need explicitly included function arguments f  condition (addition principal argument). See package vignette example uses special variables.","code":""},{"path":"/reference/rrapply.html","id":"avoid-recursing-into-list-nodes","dir":"Reference","previous_headings":"","what":"Avoid recursing into list nodes","title":"Reimplementation of base-R's rapply — rrapply","text":"default, rrapply recurses “list-like” element. classes = \"list\", behavior overridden  f function also applied list element object satisfies condition. expression objects, use  classes = \"language\", classes = \"expression\" classes = \"pairlist\" avoid recursing branches abstract  syntax tree object. condition classes arguments satisfied “list-like” element,  rrapply recurse sublist, apply f function nodes satisfy condition classes,  . Note behavior can triggered using classes argument condition argument.","code":""},{"path":"/reference/rrapply.html","id":"recursive-list-node-updating","dir":"Reference","previous_headings":"","what":"Recursive list node updating","title":"Reimplementation of base-R's rapply — rrapply","text":"classes = \"list\" = \"recurse\", rrapply applies f function list element object satisfies  condition similar previous section using = \"replace\", recurses updated list-like element  application f function. primary use = \"recurse\" combination classes = \"list\"  recursively update instance class attributes nodes nested list. Additional examples found package vignette.","code":""},{"path":"/reference/rrapply.html","id":"avoid-recursing-into-data-frames","dir":"Reference","previous_headings":"","what":"Avoid recursing into data.frames","title":"Reimplementation of base-R's rapply — rrapply","text":"classes = \"\" (default), rrapply recurses “list-like” objects equivalent rapply.  Since data.frames “list-like” objects, f function descend individual columns data.frame.  avoid behavior, set classes = \"data.frame\", case f condition functions applied directly  data.frame columns. Note behavior can triggered using classes argument condition argument.","code":""},{"path":"/reference/rrapply.html","id":"list-attributes","dir":"Reference","previous_headings":"","what":"List attributes","title":"Reimplementation of base-R's rapply — rrapply","text":"rapply intermediate list attributes (located terminal nodes) kept = \"replace\", dropped  = \"list\". avoid unexpected behavior, rrapply always preserves intermediate list attributes using = \"replace\",  = \"list\", = \"prune\" = \"names\". = \"unlist\", = \"flatten\", = \"melt\" = \"bind\"  intermediate list attributes preserved result longer nested list.","code":""},{"path":"/reference/rrapply.html","id":"expressions","dir":"Reference","previous_headings":"","what":"Expressions","title":"Reimplementation of base-R's rapply — rrapply","text":"Call objects expression vectors also accepted object argument, treated nested lists based internal abstract syntax trees. , functionality applies nested lists extends directly call objects expression vectors. object  call object expression vector, = \"replace\" always maintains type object, whereas = \"list\" returns result  structured nested list. = \"prune\", = \"flatten\" = \"melt\" return pruned abstract syntax tree : nested list,  flattened list melted data.frame respectively. identical application rrapply abstract syntax tree formatted nested list.","code":""},{"path":"/reference/rrapply.html","id":"additional-options","dir":"Reference","previous_headings":"","what":"Additional options","title":"Reimplementation of base-R's rapply — rrapply","text":"options argument accepts named list configure several default options apply certain choices . options  list can contain () named components namesep, simplify, namecols /coldepth: namesep, character separator used combine parent child list names = \"flatten\" = \"bind\". namesep = NA (default),  parent names included = \"flatten\" default separator \".\" used = \"bind\". Note namesep used  = \"unlist\" name separator always defaults \".\". simplify, logical value indicating whether flattened unnested list = \"flatten\" = \"melt\" simplified  according standard coercion rules similar = \"unlist\". default simplify = TRUE. simplify = FALSE,  object flattened single-layer list returned . namecols, logical value applies = \"bind\" indicating whether parent node names associated expanded sublist  included columns L1, L2, etc. wide data.frame returned = \"bind\". coldepth, integer value indicating depth (starting depth 1) list elements mapped individual columns  wide data.frame returned = \"bind\". coldepth = 0 (default), depth layer identified automatically based  minimal depth detected across leaf nodes. option applies = \"bind\".","code":""},{"path":[]},{"path":"/reference/rrapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reimplementation of base-R's rapply — rrapply","text":"","code":"# Example data  ## Nested list of renewable energy (%) of total energy consumption per country in 2016 data(\"renewable_energy_by_country\")  ## Subset values for countries and areas in Oceania renewable_oceania <- renewable_energy_by_country[[\"World\"]][\"Oceania\"]  ## Nested list of Pokemon properties in Pokemon GO data(\"pokedex\")  # List pruning and unnesting  ## Drop all logical NA's while preserving list structure  na_drop_oceania <- rrapply(   renewable_oceania,   f = function(x) x,   classes = \"numeric\",   how = \"prune\" ) str(na_drop_oceania, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]  ## Drop all logical NA's and return unnested list na_drop_oceania2 <- rrapply(   renewable_oceania,   f = function(x) x,   classes = \"numeric\",   how = \"flatten\" )  head(na_drop_oceania2, n = 10) #>        Australia      New Zealand             Fiji    New Caledonia  #>             9.32            32.76            24.36             4.03  #> Papua New Guinea  Solomon Islands          Vanuatu             Guam  #>            50.34            65.73            33.67             3.03  #>         Kiribati Marshall Islands  #>            45.43            11.75   ## Drop all logical NA's and return melted data.frame na_drop_oceania3 <- rrapply(   renewable_oceania,   f = identity,   classes = \"numeric\",   how = \"melt\" )  head(na_drop_oceania3) #>        L1                        L2               L3 value #> 1 Oceania Australia and New Zealand        Australia  9.32 #> 2 Oceania Australia and New Zealand      New Zealand 32.76 #> 3 Oceania                 Melanesia             Fiji 24.36 #> 4 Oceania                 Melanesia    New Caledonia  4.03 #> 5 Oceania                 Melanesia Papua New Guinea 50.34 #> 6 Oceania                 Melanesia  Solomon Islands 65.73  ## Reconstruct nested list from melted data.frame na_drop_oceania4 <- rrapply(   na_drop_oceania3,   how = \"unmelt\" )  str(na_drop_oceania4, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]  ## Convert nested list to wide data.frame pokedex_wide <- rrapply(pokedex, how = \"bind\")  head(pokedex_wide) #>   id num       name                                              img #> 1  1 001  Bulbasaur http://www.serebii.net/pokemongo/pokemon/001.png #> 2  2 002    Ivysaur http://www.serebii.net/pokemongo/pokemon/002.png #> 3  3 003   Venusaur http://www.serebii.net/pokemongo/pokemon/003.png #> 4  4 004 Charmander http://www.serebii.net/pokemongo/pokemon/004.png #> 5  5 005 Charmeleon http://www.serebii.net/pokemongo/pokemon/005.png #> 6  6 006  Charizard http://www.serebii.net/pokemongo/pokemon/006.png #>            type height   weight            candy candy_count         egg #> 1 Grass, Poison 0.71 m   6.9 kg  Bulbasaur Candy          25        2 km #> 2 Grass, Poison 0.99 m  13.0 kg  Bulbasaur Candy         100 Not in Eggs #> 3 Grass, Poison 2.01 m 100.0 kg  Bulbasaur Candy          NA Not in Eggs #> 4          Fire 0.61 m   8.5 kg Charmander Candy          25        2 km #> 5          Fire 1.09 m  19.0 kg Charmander Candy         100 Not in Eggs #> 6  Fire, Flying 1.70 m  90.5 kg Charmander Candy          NA Not in Eggs #>   spawn_chance avg_spawns spawn_time multipliers                 weaknesses #> 1       0.6900      69.00      20:00        1.58 Fire, Ice, Flying, Psychic #> 2       0.0420       4.20      07:00    1.2, 1.6 Fire, Ice, Flying, Psychic #> 3       0.0170       1.70      11:30          NA Fire, Ice, Flying, Psychic #> 4       0.2530      25.30      08:45        1.65        Water, Ground, Rock #> 5       0.0120       1.20      19:00        1.79        Water, Ground, Rock #> 6       0.0031       0.31      13:34          NA      Water, Electric, Rock #>   next_evolution.1.num next_evolution.1.name next_evolution.2.num #> 1                  002               Ivysaur                  003 #> 2                  003              Venusaur                 <NA> #> 3                 <NA>                  <NA>                 <NA> #> 4                  005            Charmeleon                  006 #> 5                  006             Charizard                 <NA> #> 6                 <NA>                  <NA>                 <NA> #>   next_evolution.2.name prev_evolution.1.num prev_evolution.1.name #> 1              Venusaur                 <NA>                  <NA> #> 2                  <NA>                  001             Bulbasaur #> 3                  <NA>                  001             Bulbasaur #> 4             Charizard                 <NA>                  <NA> #> 5                  <NA>                  004            Charmander #> 6                  <NA>                  004            Charmander #>   prev_evolution.2.num prev_evolution.2.name next_evolution.3.num #> 1                 <NA>                  <NA>                 <NA> #> 2                 <NA>                  <NA>                 <NA> #> 3                  002               Ivysaur                 <NA> #> 4                 <NA>                  <NA>                 <NA> #> 5                 <NA>                  <NA>                 <NA> #> 6                  005            Charmeleon                 <NA> #>   next_evolution.3.name #> 1                  <NA> #> 2                  <NA> #> 3                  <NA> #> 4                  <NA> #> 5                  <NA> #> 6                  <NA>  # Condition function  ## Drop all NA elements using condition function na_drop_oceania3 <- rrapply(   renewable_oceania,   condition = Negate(is.na),   f = function(x) x,   how = \"prune\" ) str(na_drop_oceania3, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]  ## Replace NA elements by a new value via the ... argument ## NB: the 'newvalue' argument should be present as function  ## argument in both 'f' and 'condition', even if unused. na_zero_oceania <- rrapply(   renewable_oceania,   condition = function(x, newvalue) is.na(x),   f = function(x, newvalue) newvalue,   newvalue = 0,   how = \"replace\" ) str(na_zero_oceania, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : num 0 #>   .. ..$ Cocos (Keeling) Islands          : num 0 #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]  ## Filter all countries with values above 85% renewable_energy_above_85 <- rrapply(   renewable_energy_by_country,   condition = function(x) x > 85,   how = \"prune\" ) str(renewable_energy_above_85, give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Africa:List of 1 #>   .. ..$ Sub-Saharan Africa:List of 3 #>   .. .. ..$ Eastern Africa:List of 7 #>   .. .. .. ..$ Burundi                    : num 89.2 #>   .. .. .. ..$ Ethiopia                   : num 91.9 #>   .. .. .. ..$ Rwanda                     : num 86 #>   .. .. .. ..$ Somalia                    : num 94.7 #>   .. .. .. ..$ Uganda                     : num 88.6 #>   .. .. .. ..$ United Republic of Tanzania: num 86.1 #>   .. .. .. ..$ Zambia                     : num 88.5 #>   .. .. ..$ Middle Africa :List of 2 #>   .. .. .. ..$ Chad                            : num 85.3 #>   .. .. .. ..$ Democratic Republic of the Congo: num 97 #>   .. .. ..$ Western Africa:List of 1 #>   .. .. .. ..$ Guinea-Bissau: num 86.5  # Special arguments .xname, .xpos, .xparents and .xsiblings  ## Apply a function using the name of the node renewable_oceania_text <- rrapply(   renewable_oceania,   f = function(x, .xname) sprintf(\"Renewable energy in %s: %.2f%%\", .xname, x),   condition = Negate(is.na),   how = \"flatten\" ) head(renewable_oceania_text, n = 10) #>                                      Australia  #>         \"Renewable energy in Australia: 9.32%\"  #>                                    New Zealand  #>      \"Renewable energy in New Zealand: 32.76%\"  #>                                           Fiji  #>             \"Renewable energy in Fiji: 24.36%\"  #>                                  New Caledonia  #>     \"Renewable energy in New Caledonia: 4.03%\"  #>                               Papua New Guinea  #> \"Renewable energy in Papua New Guinea: 50.34%\"  #>                                Solomon Islands  #>  \"Renewable energy in Solomon Islands: 65.73%\"  #>                                        Vanuatu  #>          \"Renewable energy in Vanuatu: 33.67%\"  #>                                           Guam  #>              \"Renewable energy in Guam: 3.03%\"  #>                                       Kiribati  #>         \"Renewable energy in Kiribati: 45.43%\"  #>                               Marshall Islands  #> \"Renewable energy in Marshall Islands: 11.75%\"   ## Extract values based on country names renewable_benelux <- rrapply(   renewable_energy_by_country,   condition = function(x, .xname) .xname %in% c(\"Belgium\", \"Netherlands\", \"Luxembourg\"),   how = \"prune\" ) str(renewable_benelux, give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 1 #>   .. ..$ Western Europe:List of 3 #>   .. .. ..$ Belgium    : num 9.14 #>   .. .. ..$ Luxembourg : num 13.5 #>   .. .. ..$ Netherlands: num 5.78  ## Filter European countries with value above 50% renewable_europe_above_50 <- rrapply(   renewable_energy_by_country,   condition = function(x, .xpos) identical(.xpos[c(1, 2)], c(1L, 5L)) & x > 50,   how = \"prune\" ) str(renewable_europe_above_50, give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 2 #>   .. ..$ Northern Europe:List of 3 #>   .. .. ..$ Iceland: num 78.1 #>   .. .. ..$ Norway : num 59.5 #>   .. .. ..$ Sweden : num 51.4 #>   .. ..$ Western Europe :List of 1 #>   .. .. ..$ Liechtenstein: num 62.9  ## Filter European countries with value above 50% renewable_europe_above_50 <- rrapply(   renewable_energy_by_country,   condition = function(x, .xparents) \"Europe\" %in% .xparents & x > 50,   how = \"prune\" ) str(renewable_europe_above_50, give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 2 #>   .. ..$ Northern Europe:List of 3 #>   .. .. ..$ Iceland: num 78.1 #>   .. .. ..$ Norway : num 59.5 #>   .. .. ..$ Sweden : num 51.4 #>   .. ..$ Western Europe :List of 1 #>   .. .. ..$ Liechtenstein: num 62.9  ## Return position of Sweden in list (xpos_sweden <- rrapply(   renewable_energy_by_country,   condition = function(x, .xname) identical(.xname, \"Sweden\"),   f = function(x, .xpos) .xpos,   how = \"flatten\" )) #> $Sweden #> [1]  1  5  2 14 #>  renewable_energy_by_country[[xpos_sweden$Sweden]] #> [1] 51.35 #> attr(,\"M49-code\") #> [1] \"752\"  ## Return siblings of Sweden in list siblings_sweden <- rrapply(   renewable_energy_by_country,   condition = function(x, .xsiblings) \"Sweden\" %in% names(.xsiblings),   how = \"flatten\" ) head(siblings_sweden, n = 10) #> Aland Islands       Denmark       Estonia Faroe Islands       Finland  #>            NA         33.06         26.55          4.24         42.03  #>       Iceland       Ireland   Isle of Man        Latvia     Lithuania  #>         78.07          8.65          4.30         38.48         31.42   ## Return wide Pokedex data.frame without evolutions  pokedex_small <- rrapply(    pokedex,    condition = function(x, .xparents) !any(grepl(\"evolution\", .xparents)),    how = \"bind\" )    head(pokedex_small) #>   id num       name                                              img #> 1  1 001  Bulbasaur http://www.serebii.net/pokemongo/pokemon/001.png #> 2  2 002    Ivysaur http://www.serebii.net/pokemongo/pokemon/002.png #> 3  3 003   Venusaur http://www.serebii.net/pokemongo/pokemon/003.png #> 4  4 004 Charmander http://www.serebii.net/pokemongo/pokemon/004.png #> 5  5 005 Charmeleon http://www.serebii.net/pokemongo/pokemon/005.png #> 6  6 006  Charizard http://www.serebii.net/pokemongo/pokemon/006.png #>            type height   weight            candy candy_count         egg #> 1 Grass, Poison 0.71 m   6.9 kg  Bulbasaur Candy          25        2 km #> 2 Grass, Poison 0.99 m  13.0 kg  Bulbasaur Candy         100 Not in Eggs #> 3 Grass, Poison 2.01 m 100.0 kg  Bulbasaur Candy          NA Not in Eggs #> 4          Fire 0.61 m   8.5 kg Charmander Candy          25        2 km #> 5          Fire 1.09 m  19.0 kg Charmander Candy         100 Not in Eggs #> 6  Fire, Flying 1.70 m  90.5 kg Charmander Candy          NA Not in Eggs #>   spawn_chance avg_spawns spawn_time multipliers                 weaknesses #> 1       0.6900      69.00      20:00        1.58 Fire, Ice, Flying, Psychic #> 2       0.0420       4.20      07:00    1.2, 1.6 Fire, Ice, Flying, Psychic #> 3       0.0170       1.70      11:30          NA Fire, Ice, Flying, Psychic #> 4       0.2530      25.30      08:45        1.65        Water, Ground, Rock #> 5       0.0120       1.20      19:00        1.79        Water, Ground, Rock #> 6       0.0031       0.31      13:34          NA      Water, Electric, Rock  # Modifying list elements  ## Calculate mean value of Europe rrapply(   renewable_energy_by_country,     classes = \"list\",   condition = function(x, .xname) .xname == \"Europe\",   f = function(x) mean(unlist(x), na.rm = TRUE),   how = \"flatten\" ) #>   Europe  #> 22.36565   ## Calculate mean value for each continent renewable_continent_summary <- rrapply(   renewable_energy_by_country,     classes = \"list\",   condition = function(x, .xpos) length(.xpos) == 2,   f = function(x) mean(unlist(x), na.rm = TRUE) )  ## Antarctica's value is missing str(renewable_continent_summary, give.attr = FALSE) #> List of 1 #>  $ World:List of 6 #>   ..$ Africa    : num 54.3 #>   ..$ Americas  : num 18.2 #>   ..$ Antarctica: logi NA #>   ..$ Asia      : num 17.9 #>   ..$ Europe    : num 22.4 #>   ..$ Oceania   : num 17.8  # List node updating  ## replace country names by M-49 codes renewable_M49 <- rrapply(   list(renewable_energy_by_country),    classes = \"list\",   f = function(x) {     names(x) <- vapply(x, attr, character(1L), which = \"M49-code\")     return(x)   },   how = \"recurse\" )  str(renewable_M49[[1]], max.level = 3, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ 001:List of 6 #>   ..$ 002:List of 2 #>   .. ..$ 015:List of 7 #>   .. ..$ 202:List of 4 #>   ..$ 019:List of 2 #>   .. ..$ 419:List of 3 #>   .. ..$ 021:List of 5 #>   ..$ 010: logi NA #>   .. [list output truncated]  # List attributes  ## how = \"list\" preserves all list attributes na_drop_oceania_attr <- rrapply(   renewable_oceania,   f = function(x) replace(x, is.na(x), 0),   how = \"list\" ) str(na_drop_oceania_attr, max.level = 2) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..- attr(*, \"M49-code\")= chr \"053\" #>   ..$ Melanesia                :List of 5 #>   .. ..- attr(*, \"M49-code\")= chr \"054\" #>   ..$ Micronesia               :List of 8 #>   .. ..- attr(*, \"M49-code\")= chr \"057\" #>   ..$ Polynesia                :List of 10 #>   .. ..- attr(*, \"M49-code\")= chr \"061\" #>   ..- attr(*, \"M49-code\")= chr \"009\"  ## how = \"prune\" also preserves list attributes na_drop_oceania_attr2 <- rrapply(   renewable_oceania,   condition = Negate(is.na),   how = \"prune\" ) str(na_drop_oceania_attr2, max.level = 2) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..- attr(*, \"M49-code\")= chr \"053\" #>   ..$ Melanesia                :List of 5 #>   .. ..- attr(*, \"M49-code\")= chr \"054\" #>   ..$ Micronesia               :List of 7 #>   .. ..- attr(*, \"M49-code\")= chr \"057\" #>   ..$ Polynesia                :List of 8 #>   .. ..- attr(*, \"M49-code\")= chr \"061\" #>   ..- attr(*, \"M49-code\")= chr \"009\"  # Expressions  ## Replace logicals by integers call_old <- quote(y <- x <- 1 + TRUE) call_new <- rrapply(call_old,    classes = \"logical\",    f = as.numeric,    how = \"replace\" ) str(call_new) #>  language y <- x <- 1 + 1  ## Update and decompose call object call_ast <- rrapply(call_old,    f = function(x) ifelse(is.logical(x), as.numeric(x), x),    how = \"list\" ) str(call_ast) #> List of 3 #>  $ : symbol <- #>  $ : symbol y #>  $ :List of 3 #>   ..$ : symbol <- #>   ..$ : symbol x #>   ..$ :List of 3 #>   .. ..$ : symbol + #>   .. ..$ : num 1 #>   .. ..$ : num 1  ## Prune and decompose expression expr <- expression(y <- x <- 1, f(g(2 * pi))) is_new_name <- function(x) !exists(as.character(x), envir = baseenv()) expr_prune <- rrapply(expr,    classes = \"name\",    condition = is_new_name,    how = \"prune\" ) str(expr_prune) #> List of 2 #>  $ :List of 2 #>   ..$ : symbol y #>   ..$ :List of 1 #>   .. ..$ : symbol x #>  $ :List of 2 #>   ..$ : symbol f #>   ..$ :List of 1 #>   .. ..$ : symbol g  ## Prune and flatten expression expr_flatten <- rrapply(expr,    classes = \"name\",    condition = is_new_name,    how = \"flatten\" ) str(expr_flatten) #> List of 4 #>  $ : symbol y #>  $ : symbol x #>  $ : symbol f #>  $ : symbol g  ## Prune and melt expression expr_melt <- rrapply(expr,    classes = \"name\",    condition = is_new_name,    f = as.character,   how = \"melt\" ) expr_melt #>   L1 L2   L3 value #> 1  1  2 <NA>     y #> 2  1  3    2     x #> 3  2  1 <NA>     f #> 4  2  2    1     g  ## Avoid recursing into call objects rrapply(   expr,    classes = \"language\",    condition = function(x) !any(sapply(x, is.call)),   how = \"flatten\" ) #> [[1]] #> x <- 1 #>  #> [[2]] #> 2 * pi #>"},{"path":"/news/index.html","id":"rrapply-125","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.5","title":"rrapply 1.2.5","text":"Breaking change: data.frame columns = \"bind\" include child list names instead full path names Added new option = \"names\" recursively update list names namesep, separator combine list names = \"flatten\" = \"bind\"; simplify, coerce flattened list vector = \"flatten\" = \"melt\"; namecols, include parent names columns L1, L2, … wide data.frame = \"bind\"; coldepth, override depth layer mapping list elements data.frame columns = \"bind\"","code":""},{"path":"/news/index.html","id":"rrapply-124","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.4","title":"rrapply 1.2.4","text":"CRAN release: 2022-03-07 Fixed minor issue nested data.frames using classes = \"data.frame\" = \"recurse\" Removed deprecated arguments feverywhere dfaslist","code":""},{"path":"/news/index.html","id":"rrapply-123","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.3","title":"rrapply 1.2.3","text":"CRAN release: 2021-02-08 Fixed minor bug classes argument case missing f condition arguments","code":""},{"path":"/news/index.html","id":"rrapply-122","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.2","title":"rrapply 1.2.2","text":"CRAN release: 2021-01-25 Added new option = \"bind\" unnest nested list wide data.frame Options = \"flatten\", = \"melt\" = \"bind\" coerce flat lists common types Unnamed list elements receive names \"1\", \"2\", … .xname, .xparents, = \"melt\" = \"bind\" Added pokedex demo dataset Reorganized source code","code":""},{"path":"/news/index.html","id":"rrapply-121","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.1","title":"rrapply 1.2.1","text":"CRAN release: 2020-11-07 Arguments feverywhere dfaslist deprecated favor classes (instead use classes = \"list\" classes = \"data.frame\") Added option = \"recurse\" replace deprecated feverywhere = \"recurse\" Cleaned source code fixed several minor issues","code":""},{"path":"/news/index.html","id":"rrapply-120","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.0","title":"rrapply 1.2.0","text":"CRAN release: 2020-10-12 Added support call objects expression vectors Added special argument .xsiblings evaluating sibling list f condition","code":""},{"path":"/news/index.html","id":"rrapply-111","dir":"Changelog","previous_headings":"","what":"rrapply 1.1.1","title":"rrapply 1.1.1","text":"Added new option = \"unmelt\" restore nested list melted data.frame Added special argument .xparents evaluating parent node vector f condition","code":""},{"path":"/news/index.html","id":"rrapply-110","dir":"Changelog","previous_headings":"","what":"rrapply 1.1.0","title":"rrapply 1.1.0","text":"CRAN release: 2020-07-04 Added new option = \"melt\" return melted data.frame pruned nested list Added options feverywhere = \"break\" list node aggregation feverywhere = \"recurse\" list node updating Cleaned source code fixed several minor issues","code":""}]
