[{"path":"/articles/1-when-to-use-rrapply.html","id":"list-recursion-in-r","dir":"Articles","previous_headings":"","what":"List recursion in R","title":"Efficient list recursion with rrapply","text":"nested list shows small extract Mathematics Genealogy Project highlighting advisor/student genealogy several famous mathematicians. mathematician’s given names present \"given\" attribute list element. numeric values leaf elements total number student descendants according website June 2022. descendants available missing value present leaf element. exercise list recursion, consider following simple data exploration question: Filter descendants ‘Leonhard Euler’ replace missing values zero maintaining list structure. possible (efficient) base R solution using recursion Recall() function: works, hardly kind convoluted code like write seemingly simple question. Moreover, code easy follow, can make updating modifying quite time-consuming error-prone task. alternative approach unnest list manageable (e.g. rectangular) format use specialized packages, igraph data.tree, make pruning modifying node entries straightforward. Note attention must paid correctly include node attributes transformed object node names unique example. sensible approach usually way go cleaning tidying data, fast prototyping data exploration tasks may want keep list original format reduce number processing steps minimize code complexity. Sometimes also required maintain nested data structure can instance expected input format data visualization data exporting function. recursive function makes use base rapply(), member apply-family functions R, allows apply function recursively elements nested list decide returned result structured. Although sometimes useful, existing rapply() function often sufficiently flexible list recursion tasks practice, instance pruning elements nested list (demonstrated ). context, rrapply() function minimal rrapply-package attempts enhance update base rapply() make generally applicable list recursion wild. rrapply() function builds upon R’s native C implementation ofrapply() reason requires external dependencies.","code":"students <- list(   Bernoulli = structure(list(     Bernoulli = structure(list(       Bernoulli = structure(1L, given = \"Daniel\"),       Euler = structure(list(         Euler = structure(NA, given = \"Johann\"),         Lagrange = structure(list(           Fourier = structure(73788L, given = \"Jean-Baptiste\"),            Plana = structure(NA, given = \"Giovanni\"),           Poisson = structure(128235L, given = \"Simeon\")         ), given = \"Joseph\")       ), given = \"Leonhard\")     ), given = \"Johann\"),     Bernoulli = structure(NA, given = \"Nikolaus\")   ), given = \"Jacob\") )  str(students, give.attr = FALSE) #> List of 1 #>  $ Bernoulli:List of 2 #>   ..$ Bernoulli:List of 2 #>   .. ..$ Bernoulli: int 1 #>   .. ..$ Euler    :List of 2 #>   .. .. ..$ Euler   : logi NA #>   .. .. ..$ Lagrange:List of 3 #>   .. .. .. ..$ Fourier: int 73788 #>   .. .. .. ..$ Plana  : logi NA #>   .. .. .. ..$ Poisson: int 128235 #>   ..$ Bernoulli: logi NA filter_desc_euler <- function(x) {   i <- 1   while(i <= length(x)) {     if(identical(names(x)[i], \"Euler\") & identical(attr(x[[i]], \"given\"), \"Leonhard\")) {       x[[i]] <- rapply(x[[i]], f = \\(x) replace(x, is.na(x), 0), how = \"replace\")       i <- i + 1     } else {       if(is.list(x[[i]])) {         val <- Recall(x[[i]])         x[[i]] <- val         i <- i + !is.null(val)       } else {         x[[i]] <- NULL       }       if(all(sapply(x, is.null))) {         x <- NULL       }     }   }   return(x) }  str(filter_desc_euler(students), give.attr = FALSE) #> List of 1 #>  $ Bernoulli:List of 1 #>   ..$ Bernoulli:List of 1 #>   .. ..$ Euler:List of 2 #>   .. .. ..$ Euler   : num 0 #>   .. .. ..$ Lagrange:List of 3 #>   .. .. .. ..$ Fourier: num 73788 #>   .. .. .. ..$ Plana  : num 0 #>   .. .. .. ..$ Poisson: num 128235"},{"path":"/articles/1-when-to-use-rrapply.html","id":"when-to-use-rrapply","dir":"Articles","previous_headings":"","what":"When to use rrapply()","title":"Efficient list recursion with rrapply","text":"demonstrational purposes, make use two datasets renewable_energy_by_country pokedex included rrapply-package. renewable_energy_by_country nested list containing renewable energy shares per country (% total energy consumption) 2016. data publicly available United Nations Open SDG Data Hub. 249 countries areas structured based geographical locations according United Nations M49 standard. numeric values listed country percentages, data available value country NA. pokedex nested list containing various property values 151 original Pokémon available (.json) https://github.com/Biuni/PokemonGO-Pokedex. convenience, subset values countries areas Oceania renewable_energy_by_country,","code":"library(rrapply) data(\"renewable_energy_by_country\") renewable_oceania <- renewable_energy_by_country[[\"World\"]][\"Oceania\"] str(renewable_oceania, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : logi NA #>   .. ..$ Cocos (Keeling) Islands          : logi NA #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":[]},{"path":"/articles/1-when-to-use-rrapply.html","id":"how-prune","dir":"Articles","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"how = \"prune\"","title":"Efficient list recursion with rrapply","text":"base rapply(), convenient way prune filter elements input list. rrapply() function adds option = \"prune\" prune list elements subject application function f nested list. original list structure retained, similar non-pruned versions = \"replace\" = \"list\". Using = \"prune\" syntax rapply(), can easily drop missing values list preserving nested list structure: Remark: f function missing, defaults identity function. , f argument can dropped (non-trivial) function applied list elements.","code":"## drop all logical NA's while preserving list structure  rrapply(   renewable_oceania,   f = \\(x) x,     classes = \"numeric\",   how = \"prune\" ) |>   str(list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/articles/1-when-to-use-rrapply.html","id":"how-flatten","dir":"Articles","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"how = \"flatten\"","title":"Efficient list recursion with rrapply","text":"Instead, can set = \"flatten\" return flattened unnested version pruned list. efficient first returning pruned list = \"prune\" unlisting flattening list subsequent step. Hint: options argument allows tune several options specific certain choices . = \"flatten\", can choose coerce flattened list vector /include parent list names result similar = \"unlist\" custom name separator.","code":"## drop all logical NA's and return unnested list rrapply(   renewable_oceania,   classes = \"numeric\",   how = \"flatten\" ) |>   head(n = 10) #>        Australia      New Zealand             Fiji    New Caledonia  #>             9.32            32.76            24.36             4.03  #> Papua New Guinea  Solomon Islands          Vanuatu             Guam  #>            50.34            65.73            33.67             3.03  #>         Kiribati Marshall Islands  #>            45.43            11.75 ## flatten to simple list with full names rrapply(   renewable_oceania,   classes = \"numeric\",   how = \"flatten\",   options = list(namesep = \".\", simplify = FALSE) ) |>   str(list.len = 10, give.attr = FALSE) #> List of 22 #>  $ Oceania.Australia and New Zealand.Australia        : num 9.32 #>  $ Oceania.Australia and New Zealand.New Zealand      : num 32.8 #>  $ Oceania.Melanesia.Fiji                             : num 24.4 #>  $ Oceania.Melanesia.New Caledonia                    : num 4.03 #>  $ Oceania.Melanesia.Papua New Guinea                 : num 50.3 #>  $ Oceania.Melanesia.Solomon Islands                  : num 65.7 #>  $ Oceania.Melanesia.Vanuatu                          : num 33.7 #>  $ Oceania.Micronesia.Guam                            : num 3.03 #>  $ Oceania.Micronesia.Kiribati                        : num 45.4 #>  $ Oceania.Micronesia.Marshall Islands                : num 11.8 #>   [list output truncated]"},{"path":"/articles/1-when-to-use-rrapply.html","id":"how-melt","dir":"Articles","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"how = \"melt\"","title":"Efficient list recursion with rrapply","text":"Using = \"melt\", can return melted data.frame pruned list similar format reshape2::melt() applied nested list. rows melted data.frame contain parent node paths elements pruned list. \"value\" column contains values terminal leaf nodes analogous flattened list returned = \"flatten\". Remark: names present certain sublist input list, = \"melt\" replaces names melted data.frame list element indices \"1\", \"2\", etc. melted data.frame can used reconstruct nested list = \"unmelt\". skeleton object e.g. required relist() needed, ordinary data.frame format returned = \"melt\". option can convenient construct nested lists rectangular data.frame format without resort recursive function definitions.","code":"## drop all logical NA's and return melted data.frame oceania_melt <- rrapply(   renewable_oceania,   classes = \"numeric\",   how = \"melt\" )  head(oceania_melt, n = 10) #>         L1                        L2               L3 value #> 1  Oceania Australia and New Zealand        Australia  9.32 #> 2  Oceania Australia and New Zealand      New Zealand 32.76 #> 3  Oceania                 Melanesia             Fiji 24.36 #> 4  Oceania                 Melanesia    New Caledonia  4.03 #> 5  Oceania                 Melanesia Papua New Guinea 50.34 #> 6  Oceania                 Melanesia  Solomon Islands 65.73 #> 7  Oceania                 Melanesia          Vanuatu 33.67 #> 8  Oceania                Micronesia             Guam  3.03 #> 9  Oceania                Micronesia         Kiribati 45.43 #> 10 Oceania                Micronesia Marshall Islands 11.75 ## drop some area names  renewable_oceania1 <- renewable_oceania renewable_oceania1[[1]] <- unname(renewable_oceania[[1]])  ## drop all logical NA's and return melted data.frame rrapply(   renewable_oceania1,   classes = \"numeric\",   how = \"melt\" ) |>   head(n = 10) #>         L1 L2               L3 value #> 1  Oceania  1        Australia  9.32 #> 2  Oceania  1      New Zealand 32.76 #> 3  Oceania  2             Fiji 24.36 #> 4  Oceania  2    New Caledonia  4.03 #> 5  Oceania  2 Papua New Guinea 50.34 #> 6  Oceania  2  Solomon Islands 65.73 #> 7  Oceania  2          Vanuatu 33.67 #> 8  Oceania  3             Guam  3.03 #> 9  Oceania  3         Kiribati 45.43 #> 10 Oceania  3 Marshall Islands 11.75 ## reconstruct nested list from melted data.frame rrapply(oceania_melt, how = \"unmelt\") |>   str(list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/articles/1-when-to-use-rrapply.html","id":"how-bind","dir":"Articles","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"how = \"bind\"","title":"Efficient list recursion with rrapply","text":"Nested lists containing repeated observations can unnested = \"bind\". repeated sublist expanded single row wide data.frame identical sublist component names aligned individual columns. default, list layer containing repeated observations identified minimal depth detected across leaf elements, can also overridden using coldepth option options argument. Note returned data.frame similar format repeated application tidyr::unnest_wider() nested data.frame, coercion rules applied individual columns `= “unlist”. Hint: setting namecols = TRUE options argument includes parent list names associated row wide data.frame individual columns L1, L2, etc. can useful unnest repeated list elements multiple nested list levels join results single data.frame:","code":"data(\"pokedex\") str(pokedex, list.len = 3) #> List of 1 #>  $ pokemon:List of 151 #>   ..$ :List of 16 #>   .. ..$ id            : int 1 #>   .. ..$ num           : chr \"001\" #>   .. ..$ name          : chr \"Bulbasaur\" #>   .. .. [list output truncated] #>   ..$ :List of 17 #>   .. ..$ id            : int 2 #>   .. ..$ num           : chr \"002\" #>   .. ..$ name          : chr \"Ivysaur\" #>   .. .. [list output truncated] #>   ..$ :List of 15 #>   .. ..$ id            : int 3 #>   .. ..$ num           : chr \"003\" #>   .. ..$ name          : chr \"Venusaur\" #>   .. .. [list output truncated] #>   .. [list output truncated] ## unnest list to wide data.frame rrapply(pokedex, how = \"bind\")[, c(1:3, 5:8)] |>   head(n = 10) #>    id num       name          type height   weight            candy #> 1   1 001  Bulbasaur Grass, Poison 0.71 m   6.9 kg  Bulbasaur Candy #> 2   2 002    Ivysaur Grass, Poison 0.99 m  13.0 kg  Bulbasaur Candy #> 3   3 003   Venusaur Grass, Poison 2.01 m 100.0 kg  Bulbasaur Candy #> 4   4 004 Charmander          Fire 0.61 m   8.5 kg Charmander Candy #> 5   5 005 Charmeleon          Fire 1.09 m  19.0 kg Charmander Candy #> 6   6 006  Charizard  Fire, Flying 1.70 m  90.5 kg Charmander Candy #> 7   7 007   Squirtle         Water 0.51 m   9.0 kg   Squirtle Candy #> 8   8 008  Wartortle         Water 0.99 m  22.5 kg   Squirtle Candy #> 9   9 009  Blastoise         Water 1.60 m  85.5 kg   Squirtle Candy #> 10 10 010   Caterpie           Bug 0.30 m   2.9 kg   Caterpie Candy ## bind to data.frame including parent columns pokemon_evolutions <- rrapply(   pokedex,    how = \"bind\",    options = list(namecols = TRUE, coldepth = 5) )  head(pokemon_evolutions, n = 10) #>         L1 L2             L3 L4 num       name #> 1  pokemon  1 next_evolution  1 002    Ivysaur #> 2  pokemon  1 next_evolution  2 003   Venusaur #> 3  pokemon  2 prev_evolution  1 001  Bulbasaur #> 4  pokemon  2 next_evolution  1 003   Venusaur #> 5  pokemon  3 prev_evolution  1 001  Bulbasaur #> 6  pokemon  3 prev_evolution  2 002    Ivysaur #> 7  pokemon  4 next_evolution  1 005 Charmeleon #> 8  pokemon  4 next_evolution  2 006  Charizard #> 9  pokemon  5 prev_evolution  1 004 Charmander #> 10 pokemon  5 next_evolution  1 006  Charizard ## merge pokemon evolutions with pokemon names rrapply(   pokedex,   how = \"bind\",   options = list(namecols = TRUE) )[, c(\"L1\", \"L2\", \"name\")] |>   merge(     pokemon_evolutions[, c(\"L1\", \"L2\", \"L3\", \"name\")],     by = c(\"L1\", \"L2\"),     suffixes = c(\"\", \".evolution\")   ) |>   head(n = 10) #>         L1  L2      name             L3 name.evolution #> 1  pokemon   1 Bulbasaur next_evolution        Ivysaur #> 2  pokemon   1 Bulbasaur next_evolution       Venusaur #> 3  pokemon  10  Caterpie next_evolution        Metapod #> 4  pokemon  10  Caterpie next_evolution     Butterfree #> 5  pokemon 100   Voltorb next_evolution      Electrode #> 6  pokemon 101 Electrode prev_evolution        Voltorb #> 7  pokemon 102 Exeggcute next_evolution      Exeggutor #> 8  pokemon 103 Exeggutor prev_evolution      Exeggcute #> 9  pokemon 104    Cubone next_evolution        Marowak #> 10 pokemon 105   Marowak prev_evolution         Cubone"},{"path":"/articles/1-when-to-use-rrapply.html","id":"condition-function","dir":"Articles","previous_headings":"When to use rrapply()","what":"Condition function","title":"Efficient list recursion with rrapply","text":"Base rapply() allows apply function f list elements certain types classes via classes argument. rrapply() generalizes concept via additional condition argument, accepts function use condition predicate apply f subset list elements. Conceptually, f function applied leaf elements condition function exactly evaluates TRUE similar isTRUE(). condition argument missing, f applied leaf elements. combination = \"prune\", condition function provides additional flexibility selecting filtering elements nested list, interesting consider condition also defined using classes argument. instance, can filter countries values satisfy certain numeric condition: Note NA elements returned, condition function evaluate TRUE NA values. condition function generalization classes argument, remains possible use deflt together = \"list\" = \"unlist\" set default value leaf elements condition TRUE: consistent base rapply(), deflt argument can still used combination = \"list\" = \"unlist\".","code":"## drop all NA's using condition function rrapply(   renewable_oceania,   condition = \\(x) !is.na(x),   how = \"prune\" ) |>   str(list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated] ## filter all countries with values above 85% rrapply(   renewable_energy_by_country,    condition = \\(x) x > 85,    how = \"prune\" ) |>   str(give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Africa:List of 1 #>   .. ..$ Sub-Saharan Africa:List of 3 #>   .. .. ..$ Eastern Africa:List of 7 #>   .. .. .. ..$ Burundi                    : num 89.2 #>   .. .. .. ..$ Ethiopia                   : num 91.9 #>   .. .. .. ..$ Rwanda                     : num 86 #>   .. .. .. ..$ Somalia                    : num 94.7 #>   .. .. .. ..$ Uganda                     : num 88.6 #>   .. .. .. ..$ United Republic of Tanzania: num 86.1 #>   .. .. .. ..$ Zambia                     : num 88.5 #>   .. .. ..$ Middle Africa :List of 2 #>   .. .. .. ..$ Chad                            : num 85.3 #>   .. .. .. ..$ Democratic Republic of the Congo: num 97 #>   .. .. ..$ Western Africa:List of 1 #>   .. .. .. ..$ Guinea-Bissau: num 86.5  ## or by passing arguments to condition via ... rrapply(   renewable_energy_by_country,    condition = \"==\",    e2 = 0,    how = \"prune\" ) |>   str(give.attr = FALSE) #> List of 1 #>  $ World:List of 4 #>   ..$ Americas:List of 1 #>   .. ..$ Latin America and the Caribbean:List of 1 #>   .. .. ..$ Caribbean:List of 1 #>   .. .. .. ..$ Antigua and Barbuda: num 0 #>   ..$ Asia    :List of 1 #>   .. ..$ Western Asia:List of 4 #>   .. .. ..$ Bahrain: num 0 #>   .. .. ..$ Kuwait : num 0 #>   .. .. ..$ Oman   : num 0 #>   .. .. ..$ Qatar  : num 0 #>   ..$ Europe  :List of 2 #>   .. ..$ Northern Europe:List of 1 #>   .. .. ..$ Channel Islands:List of 1 #>   .. .. .. ..$ Guernsey: num 0 #>   .. ..$ Southern Europe:List of 1 #>   .. .. ..$ Gibraltar: num 0 #>   ..$ Oceania :List of 2 #>   .. ..$ Micronesia:List of 1 #>   .. .. ..$ Northern Mariana Islands: num 0 #>   .. ..$ Polynesia :List of 1 #>   .. .. ..$ Wallis and Futuna Islands: num 0 ## replace all NA elements by zero rrapply(   renewable_oceania,    condition = Negate(is.na),    deflt = 0,    how = \"list\" ) |>   str(list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : num 0 #>   .. ..$ Cocos (Keeling) Islands          : num 0 #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/articles/1-when-to-use-rrapply.html","id":"using-the-----argument","dir":"Articles","previous_headings":"When to use rrapply() > Condition function","what":"Using the ... argument","title":"Efficient list recursion with rrapply","text":"first argument f always evaluates content list element f applied. arguments, (besides special arguments .xname, .xpos, .xparents .xsiblings discussed ), independent list content can supplied via ... argument. Since rrapply() accepts function two arguments f condition, arguments defined via ... need defined function arguments f condition functions (existing), even used function . clarify, consider following example replaces missing values value defined separate argument newvalue:","code":"## this is not ok! tryCatch({   rrapply(     renewable_oceania,      condition = is.na,      f = \\(x, newvalue) newvalue,      newvalue = 0,      how = \"replace\"   ) }, error = function(error) error$message) #> [1] \"2 arguments passed to 'is.na' which requires 1\"  ## this is ok rrapply(   renewable_oceania,    condition = \\(x, newvalue) is.na(x),    f = \\(x, newvalue) newvalue,    newvalue = 0,    how = \"replace\" ) |>   str(list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : num 0 #>   .. ..$ Cocos (Keeling) Islands          : num 0 #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/articles/1-when-to-use-rrapply.html","id":"special-arguments--xname--xpos--xparents--xsiblings","dir":"Articles","previous_headings":"When to use rrapply()","what":"Special arguments .xname, .xpos, .xparents, .xsiblings","title":"Efficient list recursion with rrapply","text":"base rapply(), f function access content list element evaluation, convenient way access name location nested list inside f function. overcome limitation, rrapply() defines special arguments .xname, .xpos, .xparents .xsiblings inside f condition functions (addition principal function argument): .xname evaluates name list element; .xpos evaluates position element nested list structured integer vector; .xparents evaluates vector parent list names path current list element; .xsiblings evaluates parent list containing current list element direct siblings. Using .xname .xpos arguments, can transform filter list elements based names /positions nested list: Knowing Europe located renewable_energy_by_country[[c(1, 5)]], can filter European countries renewable energy share 50% using .xpos argument follows, can done conveniently using .xparents argument, require looking location Europe nested list, Using .xpos argument, can quickly look position specific element nested list, Using .xsiblings argument, can look direct neighbors element nested list, can also use .xpos argument determine maximum depth list length longest sublist follows, unnesting nested lists = \"bind\", .xname, .xpos .xparents arguments can useful decide list elements include unnested data.frame:","code":"## apply f based on element's name rrapply(   renewable_oceania,   condition = \\(x) !is.na(x),   f = \\(x, .xname) sprintf(\"Renewable energy in %s: %.2f%%\", .xname, x),   how = \"flatten\" ) |>   head(n = 5) #>                                      Australia  #>         \"Renewable energy in Australia: 9.32%\"  #>                                    New Zealand  #>      \"Renewable energy in New Zealand: 32.76%\"  #>                                           Fiji  #>             \"Renewable energy in Fiji: 24.36%\"  #>                                  New Caledonia  #>     \"Renewable energy in New Caledonia: 4.03%\"  #>                               Papua New Guinea  #> \"Renewable energy in Papua New Guinea: 50.34%\"  ## filter elements by name rrapply(   renewable_energy_by_country,   condition = \\(x, .xname) .xname %in% c(\"Belgium\", \"Netherlands\", \"Luxembourg\"),   how = \"prune\" ) |>   str(give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 1 #>   .. ..$ Western Europe:List of 3 #>   .. .. ..$ Belgium    : num 9.14 #>   .. .. ..$ Luxembourg : num 13.5 #>   .. .. ..$ Netherlands: num 5.78 ## filter European countries > 50% using .xpos rrapply(   renewable_energy_by_country,   condition = \\(x, .xpos) identical(.xpos[1:2], c(1L, 5L)) && x > 50,   how = \"prune\" ) |>   str(give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 2 #>   .. ..$ Northern Europe:List of 3 #>   .. .. ..$ Iceland: num 78.1 #>   .. .. ..$ Norway : num 59.5 #>   .. .. ..$ Sweden : num 51.4 #>   .. ..$ Western Europe :List of 1 #>   .. .. ..$ Liechtenstein: num 62.9 ## filter European countries > 50% using .xparents rrapply(   renewable_energy_by_country,   condition = function(x, .xparents) \"Europe\" %in% .xparents && x > 50,   how = \"prune\" ) |>   str(give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 2 #>   .. ..$ Northern Europe:List of 3 #>   .. .. ..$ Iceland: num 78.1 #>   .. .. ..$ Norway : num 59.5 #>   .. .. ..$ Sweden : num 51.4 #>   .. ..$ Western Europe :List of 1 #>   .. .. ..$ Liechtenstein: num 62.9 ## return position of Sweden in list rrapply(   renewable_energy_by_country,   condition = \\(x, .xname) .xname == \"Sweden\",   f = \\(x, .xpos) .xpos,   how = \"flatten\" ) #> $Sweden #> [1]  1  5  2 14 ## look up neighbors of Sweden in list rrapply(   renewable_energy_by_country,   condition = \\(x, .xsiblings) \"Sweden\" %in% names(.xsiblings),   how = \"flatten\" ) |>   head(n = 10) #> Aland Islands       Denmark       Estonia Faroe Islands       Finland  #>            NA         33.06         26.55          4.24         42.03  #>       Iceland       Ireland   Isle of Man        Latvia     Lithuania  #>         78.07          8.65          4.30         38.48         31.42 ## maximum list depth rrapply(   renewable_energy_by_country,    f = \\(x, .xpos) length(.xpos),    how = \"unlist\" ) |>   max() #> [1] 5  ## longest sublist length rrapply(   renewable_energy_by_country,    f = \\(x, .xpos) max(.xpos),    how = \"unlist\" ) |>   max() #> [1] 28 ## filter elements and unnest list   rrapply(   pokedex,   condition = \\(x, .xpos, .xname) length(.xpos) < 4 & .xname %in% c(\"num\", \"name\", \"type\"),   how = \"bind\" ) |>   head() #>   num       name          type #> 1 001  Bulbasaur Grass, Poison #> 2 002    Ivysaur Grass, Poison #> 3 003   Venusaur Grass, Poison #> 4 004 Charmander          Fire #> 5 005 Charmeleon          Fire #> 6 006  Charizard  Fire, Flying"},{"path":"/articles/1-when-to-use-rrapply.html","id":"modifying-list-elements","dir":"Articles","previous_headings":"When to use rrapply()","what":"Modifying list elements","title":"Efficient list recursion with rrapply","text":"default, base rapply() rrapply() recurse list-like element. Setting classes = \"list\" rrapply() overrides behavior applies f function list element (.e. sublist) satisfies condition argument. condition satisfied list element, rrapply() recurses sublist, applies f elements satisfy condition . use classes = \"list\" signals rrapply() function descend list objects default. reason behavior can triggered via classes argument use e.g. condition = .list. mode classes = \"list\" can useful e.g. collapse sublists calculate summary statistics across elements nested list: Note principal argument f function now evaluates list. reason, first unlist sublist calculating mean. calculate mean renewable energy shares continent, can make use fact .xpos vector continent length (.e. depth) 2: Remark: classes = \"list\", f function applied (non-terminal) list elements. apply f terminal non-terminal elements nested list, can include additional classes, classes = c(\"list\", \"numeric\", \"character\"). apply f terminal non-terminal element nested list, can even combine classes = c(\"list\", \"\"). illustrate, search across list elements country region M49-code \"155\": complex example, unnest Pokémon evolutions pokedex wide data.frame returning sublists Pokémon evolutions character vectors: Hint: data.frames also list-like objects, rrapply() applies f individual data.frame columns default. Set classes = \"data.frame\" avoid behavior apply f condition functions complete data.frame objects instead individual data.frame columns.","code":"## calculate mean value of Europe rrapply(   renewable_energy_by_country,     condition = \\(x, .xname) .xname == \"Europe\",   f = \\(x) mean(unlist(x), na.rm = TRUE),   classes = \"list\",   how = \"flatten\" ) #>   Europe  #> 22.36565 ## calculate mean value for each continent ## (Antartica's value is missing) rrapply(   renewable_energy_by_country,    condition = \\(x, .xpos) length(.xpos) == 2,   f = \\(x) mean(unlist(x), na.rm = TRUE),   classes = \"list\" ) |>   str(give.attr = FALSE) #> List of 1 #>  $ World:List of 6 #>   ..$ Africa    : num 54.3 #>   ..$ Americas  : num 18.2 #>   ..$ Antarctica: logi NA #>   ..$ Asia      : num 17.9 #>   ..$ Europe    : num 22.4 #>   ..$ Oceania   : num 17.8 ## filter country or region by M49-code rrapply(   renewable_energy_by_country,   condition = \\(x) attr(x, \"M49-code\") == \"155\",   f = \\(x, .xname) .xname,   classes = c(\"list\", \"ANY\"),    how = \"unlist\" ) #> World.Europe.Western Europe  #>            \"Western Europe\" ## simplify pokemon evolutions to character vectors  rrapply(   pokedex,   condition = \\(x, .xname) .xname %in% c(\"name\", \"next_evolution\", \"prev_evolution\"),    f = \\(x) if(is.list(x)) sapply(x, `[[`, \"name\") else x,   classes = c(\"list\", \"character\"),   how = \"bind\" ) |>   head(n = 9) #>         name        next_evolution         prev_evolution #> 1  Bulbasaur     Ivysaur, Venusaur                     NA #> 2    Ivysaur              Venusaur              Bulbasaur #> 3   Venusaur                    NA     Bulbasaur, Ivysaur #> 4 Charmander Charmeleon, Charizard                     NA #> 5 Charmeleon             Charizard             Charmander #> 6  Charizard                    NA Charmander, Charmeleon #> 7   Squirtle  Wartortle, Blastoise                     NA #> 8  Wartortle             Blastoise               Squirtle #> 9  Blastoise                    NA    Squirtle, Wartortle ## create a nested list of data.frames oceania_df <- rrapply(   renewable_oceania,   condition = \\(x, .xpos) length(.xpos) == 2,   f = \\(x) data.frame(name = names(x), value = unlist(x)),   classes = \"list\",   how = \"replace\" )  ## this does not work! tryCatch({   rrapply(     oceania_df,     f = function(x) subset(x, !is.na(value)), ## filter NA-rows of data.frame     how = \"replace\"   ) }, error = function(error) error$message) #> [1] \"object 'value' not found\"  ## this does work rrapply(   oceania_df,   f = function(x) subset(x, !is.na(value)),   classes = \"data.frame\",   how = \"replace\" )[[1]][1:2] #> $`Australia and New Zealand` #>                    name value #> Australia     Australia  9.32 #> New Zealand New Zealand 32.76 #>  #> $Melanesia #>                              name value #> Fiji                         Fiji 24.36 #> New Caledonia       New Caledonia  4.03 #> Papua New Guinea Papua New Guinea 50.34 #> Solomon Islands   Solomon Islands 65.73 #> Vanuatu                   Vanuatu 33.67"},{"path":[]},{"path":"/articles/1-when-to-use-rrapply.html","id":"how-recurse","dir":"Articles","previous_headings":"When to use rrapply() > Recursive list updating","what":"how = \"recurse\"","title":"Efficient list recursion with rrapply","text":"classes = \"list\" = \"recurse\", rrapply() applies f function list element satisfies condition argument, recurses updated list element application f. can useful e.g. recursively update class attributes elements nested list:","code":"## recursively remove all list attributes rrapply(   renewable_oceania,   f = \\(x) c(x),   classes = c(\"list\", \"ANY\"),   how = \"recurse\" ) |>   str(list.len = 3, give.attr = TRUE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : logi NA #>   .. ..$ Cocos (Keeling) Islands          : logi NA #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/articles/1-when-to-use-rrapply.html","id":"how-names","dir":"Articles","previous_headings":"When to use rrapply() > Recursive list updating","what":"how = \"names\"","title":"Efficient list recursion with rrapply","text":"option = \"names\" special case = \"recurse\", value f used replace name evaluated list element instead content (options). default, = \"names\" uses classes = c(\"list\", \"\") order allow updating names nested list.","code":"## recursively replace all names by M49-codes rrapply(   renewable_oceania,   f = \\(x) attr(x, \"M49-code\"),   how = \"names\" ) |>   str(list.len = 3, give.attr = FALSE) #> List of 1 #>  $ 009:List of 4 #>   ..$ 053:List of 6 #>   .. ..$ 036: num 9.32 #>   .. ..$ 162: logi NA #>   .. ..$ 166: logi NA #>   .. .. [list output truncated] #>   ..$ 054:List of 5 #>   .. ..$ 242: num 24.4 #>   .. ..$ 540: num 4.03 #>   .. ..$ 598: num 50.3 #>   .. .. [list output truncated] #>   ..$ 057:List of 8 #>   .. ..$ 316: num 3.03 #>   .. ..$ 296: num 45.4 #>   .. ..$ 584: num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/articles/1-when-to-use-rrapply.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Efficient list recursion with rrapply","text":"conclude, return list recursion exercise first section. Using rrapply(), one possible solution split question two steps follows: Knowing Johann Euler descendant Leonhard Euler, can simplify single function call using .xparents argument: alternatively, first update names elements nested list include first last names prune list second step:","code":"## look up position of Euler (Leonhard) euler <- rrapply(   students,   condition = \\(x, .xname) .xname == \"Euler\" && attr(x, \"given\") == \"Leonhard\",   f = \\(x, .xpos) .xpos,   classes = \"list\",   how = \"flatten\" )[[\"Euler\"]]  ## filter descendants of Euler (Leonhard) and replace missing values by zero rrapply(   students,   condition = \\(x, .xpos) identical(.xpos[seq_along(euler)], euler),    f = \\(x) replace(x, is.na(x), 0),   how = \"prune\" ) |>   str(give.attr = FALSE) #> List of 1 #>  $ Bernoulli:List of 1 #>   ..$ Bernoulli:List of 1 #>   .. ..$ Euler:List of 2 #>   .. .. ..$ Euler   : num 0 #>   .. .. ..$ Lagrange:List of 3 #>   .. .. .. ..$ Fourier: num 73788 #>   .. .. .. ..$ Plana  : num 0 #>   .. .. .. ..$ Poisson: num 128235 ## filter descendants of Euler (Leonhard) and replace missing values by zero rrapply(   students,   condition = \\(x, .xparents) \"Euler\" %in% .xparents,   f = \\(x) replace(x, is.na(x), 0),   how = \"prune\" ) |>   str(give.attr = FALSE) #> List of 1 #>  $ Bernoulli:List of 1 #>   ..$ Bernoulli:List of 1 #>   .. ..$ Euler:List of 2 #>   .. .. ..$ Euler   : num 0 #>   .. .. ..$ Lagrange:List of 3 #>   .. .. .. ..$ Fourier: num 73788 #>   .. .. .. ..$ Plana  : num 0 #>   .. .. .. ..$ Poisson: num 128235 ## include first names in list element names students_fullnames <- rrapply(   students,    f = \\(x, .xname) paste(attr(x, \"given\"), .xname),   how = \"names\" )  ## filter descendants of Euler (Leonhard) and replace missing values by zero rrapply(   students_fullnames,   condition = \\(x, .xparents) \"Leonhard Euler\" %in% .xparents,   f = \\(x) replace(x, is.na(x), 0),   how = \"prune\" ) |>   str(give.attr = FALSE) #> List of 1 #>  $ Jacob Bernoulli:List of 1 #>   ..$ Johann Bernoulli:List of 1 #>   .. ..$ Leonhard Euler:List of 2 #>   .. .. ..$ Johann Euler   : num 0 #>   .. .. ..$ Joseph Lagrange:List of 3 #>   .. .. .. ..$ Jean-Baptiste Fourier: num 73788 #>   .. .. .. ..$ Giovanni Plana       : num 0 #>   .. .. .. ..$ Simeon Poisson       : num 128235"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Efficient list melting and unnesting with rrapply","text":"previous article vignette(\"1---use-rrapply\") describes principal use rrapply() function revised extended version base rapply() context nested list recursion. quick data exploration nested list can make sense keep list original nested format reduce number processing steps minimize code complexity. part elaborate data analysis, specific reason keep nested data structure, often practical transform nested list convenient rectangular format work unnested object (e.g. data.frame) instead. follow-article, review available () options rrapply() unnest melt nested lists rectangular format detail highlight similarities differences respect several common alternatives R.","code":""},{"path":[]},{"path":"/articles/2-efficient-melting-unnesting.html","id":"melt-to-long-data-frame","dir":"Articles","previous_headings":"Nested list to data.frame","what":"Melt to long data.frame","title":"Efficient list melting and unnesting with rrapply","text":"option = \"melt\" rrapply() unnests nested list long melted data.frame similar format retired reshape2::melt() function applied nested list. rows melted data.frame contain individual node paths elements nested list pruning (based condition /classes arguments). \"value\" column vector- list-column containing values leaf elements identical object returned = \"flatten\". demonstrate, use renewable_energy_by_country dataset included rrapply-package, nested list containing renewable energy shares per country (% total energy consumption) 20161. 249 countries areas structured based geographical locations according United Nations M49 standard. numeric values listed country percentages, data available value country NA. shown examples, comparison reshape2::melt(), rrapply() allows filter transform list elements melting nested list f, classes condition arguments2. importantly, rrapply() optimized specifically handling nested lists, whereas reshape2::melt() aimed primarily melting data.frames superseded tidyr::gather() recently tidyr::pivot_longer(). reason, reshape2::melt() can quite slow applied large nested lists: medium-sized list used example, computation time reshape2::melt() bottleneck practical usage. However, computational effort quickly increases melting larger deeply nested lists: Although unlikely encounter large deeply nested lists practice, artificial examples serve illustrate reshape2::melt() particularly efficient unnesting large nested lists data.frames.","code":"library(rrapply)  ## melt all data to long data.frame rrapply(   renewable_energy_by_country,    how = \"melt\" ) |>   head(n = 10) #>       L1     L2                 L3             L4                             L5 value #> 1  World Africa    Northern Africa        Algeria                           <NA>  0.08 #> 2  World Africa    Northern Africa          Egypt                           <NA>  5.69 #> 3  World Africa    Northern Africa          Libya                           <NA>  1.64 #> 4  World Africa    Northern Africa        Morocco                           <NA> 11.02 #> 5  World Africa    Northern Africa          Sudan                           <NA> 61.64 #> 6  World Africa    Northern Africa        Tunisia                           <NA> 12.47 #> 7  World Africa    Northern Africa Western Sahara                           <NA>    NA #> 8  World Africa Sub-Saharan Africa Eastern Africa British Indian Ocean Territory    NA #> 9  World Africa Sub-Saharan Africa Eastern Africa                        Burundi 89.22 #> 10 World Africa Sub-Saharan Africa Eastern Africa                        Comoros 41.92 ## drop logical NA's and melt to data.frame rrapply(   renewable_energy_by_country,   classes = \"numeric\",   how = \"melt\" ) |>   head(n = 10) #>       L1     L2                 L3             L4       L5 value #> 1  World Africa    Northern Africa        Algeria     <NA>  0.08 #> 2  World Africa    Northern Africa          Egypt     <NA>  5.69 #> 3  World Africa    Northern Africa          Libya     <NA>  1.64 #> 4  World Africa    Northern Africa        Morocco     <NA> 11.02 #> 5  World Africa    Northern Africa          Sudan     <NA> 61.64 #> 6  World Africa    Northern Africa        Tunisia     <NA> 12.47 #> 7  World Africa Sub-Saharan Africa Eastern Africa  Burundi 89.22 #> 8  World Africa Sub-Saharan Africa Eastern Africa  Comoros 41.92 #> 9  World Africa Sub-Saharan Africa Eastern Africa Djibouti 28.50 #> 10 World Africa Sub-Saharan Africa Eastern Africa  Eritrea 80.14 ## apply condition and melt to data.frame rrapply(   renewable_energy_by_country,   condition = \\(x, .xparents) \"Western Europe\" %in% .xparents,   how = \"melt\" ) |>   head(n = 10) #>      L1     L2             L3            L4 value #> 1 World Europe Western Europe       Austria 34.67 #> 2 World Europe Western Europe       Belgium  9.14 #> 3 World Europe Western Europe        France 14.74 #> 4 World Europe Western Europe       Germany 14.17 #> 5 World Europe Western Europe Liechtenstein 62.93 #> 6 World Europe Western Europe    Luxembourg 13.54 #> 7 World Europe Western Europe        Monaco    NA #> 8 World Europe Western Europe   Netherlands  5.78 #> 9 World Europe Western Europe   Switzerland 25.49 ## melt to long data.frame (reshape2) reshape2::melt(renewable_energy_by_country) |>   head(10) #>    value             L4                             L5                 L3     L2    L1 #> 1   0.08        Algeria                           <NA>    Northern Africa Africa World #> 2   5.69          Egypt                           <NA>    Northern Africa Africa World #> 3   1.64          Libya                           <NA>    Northern Africa Africa World #> 4  11.02        Morocco                           <NA>    Northern Africa Africa World #> 5  61.64          Sudan                           <NA>    Northern Africa Africa World #> 6  12.47        Tunisia                           <NA>    Northern Africa Africa World #> 7     NA Western Sahara                           <NA>    Northern Africa Africa World #> 8     NA Eastern Africa British Indian Ocean Territory Sub-Saharan Africa Africa World #> 9  89.22 Eastern Africa                        Burundi Sub-Saharan Africa Africa World #> 10 41.92 Eastern Africa                        Comoros Sub-Saharan Africa Africa World  ## computation times bench::mark(   rrapply(renewable_energy_by_country),   reshape2::melt(renewable_energy_by_country),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression                                       min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>                                  <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 rrapply(renewable_energy_by_country)          12.9µs   15.1µs   64389.         0B     25.8 #> 2 reshape2::melt(renewable_energy_by_country)   47.8ms     48ms      20.8    73.1KB     83.3 ## helper function to generate large nested list new_list <- function(n, d) {   v <- vector(mode = \"list\", length = n)   rrapply(     object = v,     classes = c(\"list\", \"NULL\"),     condition = \\(x, .xpos) length(.xpos) <= d,     f = \\(x, .xpos) if(length(.xpos) < d) v else runif(1),     how = \"recurse\"   ) }  ## random seed set.seed(1)  ## generate large shallow list (10^6 elements) shallow_list <- new_list(n = 100, d = 3) str(shallow_list, list.len = 2) #> List of 100 #>  $ :List of 100 #>   ..$ :List of 100 #>   .. ..$ : num 0.266 #>   .. ..$ : num 0.372 #>   .. .. [list output truncated] #>   ..$ :List of 100 #>   .. ..$ : num 0.655 #>   .. ..$ : num 0.353 #>   .. .. [list output truncated] #>   .. [list output truncated] #>  $ :List of 100 #>   ..$ :List of 100 #>   .. ..$ : num 0.0647 #>   .. ..$ : num 0.677 #>   .. .. [list output truncated] #>   ..$ :List of 100 #>   .. ..$ : num 0.266 #>   .. ..$ : num 0.66 #>   .. .. [list output truncated] #>   .. [list output truncated] #>   [list output truncated]  ## benchmark timing with rrapply system.time(shallow_melt <- rrapply(shallow_list, how = \"melt\"))  #>    user  system elapsed  #>   1.070   0.032   1.102 head(shallow_melt) #>   L1 L2 L3     value #> 1  1  1  1 0.2655087 #> 2  1  1  2 0.3721239 #> 3  1  1  3 0.5728534 #> 4  1  1  4 0.9082078 #> 5  1  1  5 0.2016819 #> 6  1  1  6 0.8983897  ## benchmark timing with reshape2::melt system.time(shallow_melt_reshape2 <- reshape2::melt(shallow_list)) #>    user  system elapsed  #> 146.701   0.015 146.733 head(shallow_melt_reshape2) #>       value L3 L2 L1 #> 1 0.2655087  1  1  1 #> 2 0.3721239  2  1  1 #> 3 0.5728534  3  1  1 #> 4 0.9082078  4  1  1 #> 5 0.2016819  5  1  1 #> 6 0.8983897  6  1  1 ## generate large deeply nested list (2^18 elements) deep_list <- new_list(n = 2, d = 18)  ## benchmark timing with rrapply system.time(deep_melt <- rrapply(deep_list, how = \"melt\"))  #>    user  system elapsed  #>   0.671   0.012   0.682 head(deep_melt) #>   L1 L2 L3 L4 L5 L6 L7 L8 L9 L10 L11 L12 L13 L14 L15 L16 L17 L18      value #> 1  1  1  1  1  1  1  1  1  1   1   1   1   1   1   1   1   1   1 0.14011775 #> 2  1  1  1  1  1  1  1  1  1   1   1   1   1   1   1   1   1   2 0.69562066 #> 3  1  1  1  1  1  1  1  1  1   1   1   1   1   1   1   1   2   1 0.72888445 #> 4  1  1  1  1  1  1  1  1  1   1   1   1   1   1   1   1   2   2 0.09164734 #> 5  1  1  1  1  1  1  1  1  1   1   1   1   1   1   1   2   1   1 0.06661200 #> 6  1  1  1  1  1  1  1  1  1   1   1   1   1   1   1   2   1   2 0.61285721  ## benchmark timing with reshape2::melt system.time(deep_melt_reshape2 <- reshape2::melt(deep_list)) #>    user  system elapsed  #> 116.445   0.036 116.486 head(deep_melt_reshape2) #>        value L18 L17 L16 L15 L14 L13 L12 L11 L10 L9 L8 L7 L6 L5 L4 L3 L2 L1 #> 1 0.14011775   1   1   1   1   1   1   1   1   1  1  1  1  1  1  1  1  1  1 #> 2 0.69562066   2   1   1   1   1   1   1   1   1  1  1  1  1  1  1  1  1  1 #> 3 0.72888445   1   2   1   1   1   1   1   1   1  1  1  1  1  1  1  1  1  1 #> 4 0.09164734   2   2   1   1   1   1   1   1   1  1  1  1  1  1  1  1  1  1 #> 5 0.06661200   1   1   2   1   1   1   1   1   1  1  1  1  1  1  1  1  1  1 #> 6 0.61285721   2   1   2   1   1   1   1   1   1  1  1  1  1  1  1  1  1  1"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"bind-to-wide-data-frame","dir":"Articles","previous_headings":"Nested list to data.frame","what":"Bind to wide data.frame","title":"Efficient list melting and unnesting with rrapply","text":"option = \"bind\" unnests nested list wide data.frame used unnest nested lists containing repeated entries variables. illustrate, consider pokedex dataset included rrapply-package, nested list containing various property values 151 original Pokémon available (.json) https://github.com/Biuni/PokemonGO-Pokedex. Calling rrapply() = \"bind expands Pokémon sublist single row wide data.frame. 151 rows stacked aligned matching variable names, missing entries replaced NA’s (similar data.table::rbindlist(..., fill = TRUE)). Note nested variables, next_evolution prev_evolution, unnested wide possible individual data.frame columns similar repeated application tidyr::unnest_wider() data.frame nested list-columns. default, list layer containing repeated observations identified minimal depth detected across leaf elements. option can overridden coldepth parameter options argument, can useful unnest nested sublists, next_evolution prev_evolution. addition, setting namecols = TRUE options argument includes parent list names associated row wide data.frame individual columns L1, L2, etc.","code":"## all 151 Pokemon str(pokedex, list.len = 3) #> List of 1 #>  $ pokemon:List of 151 #>   ..$ :List of 16 #>   .. ..$ id            : int 1 #>   .. ..$ num           : chr \"001\" #>   .. ..$ name          : chr \"Bulbasaur\" #>   .. .. [list output truncated] #>   ..$ :List of 17 #>   .. ..$ id            : int 2 #>   .. ..$ num           : chr \"002\" #>   .. ..$ name          : chr \"Ivysaur\" #>   .. .. [list output truncated] #>   ..$ :List of 15 #>   .. ..$ id            : int 3 #>   .. ..$ num           : chr \"003\" #>   .. ..$ name          : chr \"Venusaur\" #>   .. .. [list output truncated] #>   .. [list output truncated]  ## single Pokemon entry str(pokedex[[\"pokemon\"]][[1]]) #> List of 16 #>  $ id            : int 1 #>  $ num           : chr \"001\" #>  $ name          : chr \"Bulbasaur\" #>  $ img           : chr \"http://www.serebii.net/pokemongo/pokemon/001.png\" #>  $ type          : chr [1:2] \"Grass\" \"Poison\" #>  $ height        : chr \"0.71 m\" #>  $ weight        : chr \"6.9 kg\" #>  $ candy         : chr \"Bulbasaur Candy\" #>  $ candy_count   : int 25 #>  $ egg           : chr \"2 km\" #>  $ spawn_chance  : num 0.69 #>  $ avg_spawns    : int 69 #>  $ spawn_time    : chr \"20:00\" #>  $ multipliers   : num 1.58 #>  $ weaknesses    : chr [1:4] \"Fire\" \"Ice\" \"Flying\" \"Psychic\" #>  $ next_evolution:List of 2 #>   ..$ :List of 2 #>   .. ..$ num : chr \"002\" #>   .. ..$ name: chr \"Ivysaur\" #>   ..$ :List of 2 #>   .. ..$ num : chr \"003\" #>   .. ..$ name: chr \"Venusaur\" rrapply(pokedex, how = \"bind\")[, 1:9] |>   head() #>   id num       name                                              img          type height   weight            candy candy_count #> 1  1 001  Bulbasaur http://www.serebii.net/pokemongo/pokemon/001.png Grass, Poison 0.71 m   6.9 kg  Bulbasaur Candy          25 #> 2  2 002    Ivysaur http://www.serebii.net/pokemongo/pokemon/002.png Grass, Poison 0.99 m  13.0 kg  Bulbasaur Candy         100 #> 3  3 003   Venusaur http://www.serebii.net/pokemongo/pokemon/003.png Grass, Poison 2.01 m 100.0 kg  Bulbasaur Candy          NA #> 4  4 004 Charmander http://www.serebii.net/pokemongo/pokemon/004.png          Fire 0.61 m   8.5 kg Charmander Candy          25 #> 5  5 005 Charmeleon http://www.serebii.net/pokemongo/pokemon/005.png          Fire 1.09 m  19.0 kg Charmander Candy         100 #> 6  6 006  Charizard http://www.serebii.net/pokemongo/pokemon/006.png  Fire, Flying 1.70 m  90.5 kg Charmander Candy          NA ## bind prev/next evolution columns rrapply(   pokedex,    how = \"bind\",   options = list(coldepth = 5, namecols = TRUE) ) |>   head(n = 10) #>         L1 L2             L3 L4 num       name #> 1  pokemon  1 next_evolution  1 002    Ivysaur #> 2  pokemon  1 next_evolution  2 003   Venusaur #> 3  pokemon  2 prev_evolution  1 001  Bulbasaur #> 4  pokemon  2 next_evolution  1 003   Venusaur #> 5  pokemon  3 prev_evolution  1 001  Bulbasaur #> 6  pokemon  3 prev_evolution  2 002    Ivysaur #> 7  pokemon  4 next_evolution  1 005 Charmeleon #> 8  pokemon  4 next_evolution  2 006  Charizard #> 9  pokemon  5 prev_evolution  1 004 Charmander #> 10 pokemon  5 next_evolution  1 006  Charizard"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"common-alternatives","dir":"Articles","previous_headings":"Nested list to data.frame > Bind to wide data.frame","what":"Common alternatives","title":"Efficient list melting and unnesting with rrapply","text":"Several common alternatives used unnest lists containing repeated entries include data.table::rbindlist(), dplyr::bind_rows(), tidyr’s dedicated rectangling functions unnest_longer(), unnest_wider() hoist(). first two functions primarily aimed binding lists data.frames lists lists, meant nested lists containing multiple levels nesting, pokedex: rectangling functions tidyr-package offer lot flexibility. similar data.frame returned rrapply(pokedex, = \"bind\") can obtained repeated application tidyr::unnest_wider(): option = \"bind\" rrapply() less flexible always expands nested list data.frame wide possible. hand, flexibility interpretability tidyr’s rectangling functions come cost increased computational effort, can become bottleneck unnesting large nested lists: Remark: chained calls unnest_wider() , unnest first layer next_evolution prev_evolution list-columns, resulting children list-columns, increase computation time. extract unnest sublists deeper levels nesting list, next_evolution, manually set coldepth parameter options argument, also demonstrated : unnested version next_evolution sublists can obtained mixing several calls unnest_wider() unnest_longer(): context current example, efficient approach combine unnest_wider() hoist(). disadvantage need manually specify exact locations elements wish hoist nested list: Using rrapply(), result can obtained adding call reshape() (alternatively e.g. tidyr::pivot_wider() data.table::dcast()) converting long wide data.frame:","code":"library(dplyr)  ## simple list of lists lapply(pokedex[[\"pokemon\"]], `[`, 1:4) |>   bind_rows() |>    head() #> # A tibble: 6 × 4 #>      id num   name       img                                              #>   <int> <chr> <chr>      <chr>                                            #> 1     1 001   Bulbasaur  http://www.serebii.net/pokemongo/pokemon/001.png #> 2     2 002   Ivysaur    http://www.serebii.net/pokemongo/pokemon/002.png #> 3     3 003   Venusaur   http://www.serebii.net/pokemongo/pokemon/003.png #> 4     4 004   Charmander http://www.serebii.net/pokemongo/pokemon/004.png #> 5     5 005   Charmeleon http://www.serebii.net/pokemongo/pokemon/005.png #> 6     6 006   Charizard  http://www.serebii.net/pokemongo/pokemon/006.png  ## complex nested list (error) bind_rows(pokedex[[\"pokemon\"]]) #> Error in `vctrs::data_frame()`: #> ! Can't recycle `id` (size 2) to match `weaknesses` (size 4).  ## simple list of lists lapply(pokedex[[\"pokemon\"]], `[`, 1:4) |>   data.table::rbindlist() |>   head() #>    id num       name                                              img #> 1:  1 001  Bulbasaur http://www.serebii.net/pokemongo/pokemon/001.png #> 2:  2 002    Ivysaur http://www.serebii.net/pokemongo/pokemon/002.png #> 3:  3 003   Venusaur http://www.serebii.net/pokemongo/pokemon/003.png #> 4:  4 004 Charmander http://www.serebii.net/pokemongo/pokemon/004.png #> 5:  5 005 Charmeleon http://www.serebii.net/pokemongo/pokemon/005.png #> 6:  6 006  Charizard http://www.serebii.net/pokemongo/pokemon/006.png  ## complex nested list (error) data.table::rbindlist(pokedex[[\"pokemon\"]]) #> Error in data.table::rbindlist(pokedex[[\"pokemon\"]]): Column 5 of item 1 is length 2 inconsistent with column 15 which is length 4. Only length-1 columns are recycled. library(tidyr) library(tibble)  as_tibble(pokedex) |>   unnest_wider(pokemon) |>   unnest_wider(next_evolution, names_sep = \".\") |>   unnest_wider(prev_evolution, names_sep = \".\") |>   unnest_wider(next_evolution.1, names_sep = \".\") |>   unnest_wider(next_evolution.2, names_sep = \".\") |>   unnest_wider(next_evolution.3, names_sep = \".\") |>   unnest_wider(prev_evolution.1, names_sep = \".\") |>   unnest_wider(prev_evolution.2, names_sep = \".\") |>   head() #> # A tibble: 6 × 25 #>      id num   name       img   type  height weight candy candy…¹ egg   spawn…² avg_s…³ spawn…⁴ multi…⁵ weakn…⁶ next_…⁷ next_…⁸ next_…⁹ next_…˟ next_…˟ #>   <int> <chr> <chr>      <chr> <lis> <chr>  <chr>  <chr>   <int> <chr>   <dbl>   <dbl> <chr>   <list>  <list>  <chr>   <chr>   <chr>   <chr>   <chr>   #> 1     1 001   Bulbasaur  http… <chr> 0.71 m 6.9 kg Bulb…      25 2 km   0.69     69    20:00   <dbl>   <chr>   002     Ivysaur 003     Venusa… NA      #> 2     2 002   Ivysaur    http… <chr> 0.99 m 13.0 … Bulb…     100 Not …  0.042     4.2  07:00   <dbl>   <chr>   003     Venusa… NA      NA      NA      #> 3     3 003   Venusaur   http… <chr> 2.01 m 100.0… Bulb…      NA Not …  0.017     1.7  11:30   <dbl>   <chr>   NA      NA      NA      NA      NA      #> 4     4 004   Charmander http… <chr> 0.61 m 8.5 kg Char…      25 2 km   0.253    25.3  08:45   <dbl>   <chr>   005     Charme… 006     Chariz… NA      #> 5     5 005   Charmeleon http… <chr> 1.09 m 19.0 … Char…     100 Not …  0.012     1.2  19:00   <dbl>   <chr>   006     Chariz… NA      NA      NA      #> 6     6 006   Charizard  http… <chr> 1.70 m 90.5 … Char…      NA Not …  0.0031    0.31 13:34   <dbl>   <chr>   NA      NA      NA      NA      NA      #> # … with 5 more variables: next_evolution.3.name <chr>, prev_evolution.1.num <chr>, prev_evolution.1.name <chr>, prev_evolution.2.num <chr>, #> #   prev_evolution.2.name <chr>, and abbreviated variable names ¹​candy_count, ²​spawn_chance, ³​avg_spawns, ⁴​spawn_time, ⁵​multipliers, ⁶​weaknesses, #> #   ⁷​next_evolution.1.num, ⁸​next_evolution.1.name, ⁹​next_evolution.2.num, ˟​next_evolution.2.name, ˟​next_evolution.3.num #> # ℹ Use `colnames()` to see all variable names ## large replicated pokedex list  pokedex_large <- list(pokemon = do.call(c, replicate(1500, pokedex[[\"pokemon\"]], simplify = FALSE)))  system.time({   rrapply(pokedex_large, how = \"bind\") }) #>    user  system elapsed  #>   2.094   0.032   2.125  ## unnest first layers prev_evolution and next_evolution system.time({   as_tibble(pokedex_large) |>     unnest_wider(pokemon) |>     unnest_wider(next_evolution, names_sep = \".\") |>     unnest_wider(prev_evolution, names_sep = \".\")  }) #>    user  system elapsed  #> 113.796   0.336 114.139 system.time({   ev1 <- rrapply(     pokedex_large,      condition = \\(x, .xparents) \"next_evolution\" %in% .xparents,     how = \"bind\",     options = list(namecols = TRUE, coldepth = 5)   ) }) #>    user  system elapsed  #>   1.562   0.000   1.562 head(ev1) #>        L1 L2             L3 L4 num       name #> 1 pokemon  1 next_evolution  1 002    Ivysaur #> 2 pokemon  1 next_evolution  2 003   Venusaur #> 3 pokemon  2 next_evolution  1 003   Venusaur #> 4 pokemon  4 next_evolution  1 005 Charmeleon #> 5 pokemon  4 next_evolution  2 006  Charizard #> 6 pokemon  5 next_evolution  1 006  Charizard system.time({   ev2 <- as_tibble(pokedex_large) |>     unnest_wider(pokemon) |>     unnest_longer(next_evolution) |>     unnest_wider(next_evolution, names_sep = \"_\") |>     select(id, next_evolution_num, next_evolution_name) }) #>    user  system elapsed  #>  90.052   0.076  90.142 head(ev2) #> # A tibble: 6 × 3 #>      id next_evolution_num next_evolution_name #>   <int> <chr>              <chr>               #> 1     1 002                Ivysaur             #> 2     1 003                Venusaur            #> 3     2 003                Venusaur            #> 4     3 NA                 NA                  #> 5     4 005                Charmeleon          #> 6     4 006                Charizard system.time({   ev3 <- as_tibble(pokedex_large) |>     unnest_wider(pokemon) |>     hoist(next_evolution,            name.1 = list(1, \"name\"),           name.2 = list(2, \"name\"),           name.3 = list(3, \"name\")     ) |>     select(id, name.1, name.2, name.3) }) #>    user  system elapsed  #>  40.731   0.000  40.734 head(ev3) #> # A tibble: 6 × 4 #>      id name.1     name.2    name.3 #>   <int> <chr>      <chr>     <chr>  #> 1     1 Ivysaur    Venusaur  NA     #> 2     2 Venusaur   NA        NA     #> 3     3 NA         NA        NA     #> 4     4 Charmeleon Charizard NA     #> 5     5 Charizard  NA        NA     #> 6     6 NA         NA        NA system.time({   ev4 <- rrapply(     pokedex_large,      condition = \\(x, .xparents) \"next_evolution\" %in% .xparents,     how = \"bind\",      options = list(namecols = TRUE, coldepth = 5)   )    ev5 <- reshape(     ev4[, c(\"L2\", \"L4\", \"name\")],     idvar = \"L2\",     timevar = \"L4\",     v.names = \"name\",     direction = \"wide\"   ) }) #>    user  system elapsed  #>   2.146   0.000   2.146 head(ev5) #>   L2     name.1    name.2 name.3 #> 1  1    Ivysaur  Venusaur   <NA> #> 3  2   Venusaur      <NA>   <NA> #> 4  4 Charmeleon Charizard   <NA> #> 6  5  Charizard      <NA>   <NA> #> 7  7  Wartortle Blastoise   <NA> #> 9  8  Blastoise      <NA>   <NA>"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"additional-examples","dir":"Articles","previous_headings":"Nested list to data.frame > Bind to wide data.frame","what":"Additional examples","title":"Efficient list melting and unnesting with rrapply","text":"conclude section replicating data rectangling examples presented tidyr vignette: https://tidyr.tidyverse.org/articles/rectangle.html. example nested lists conveniently included repurrrsive-package.","code":""},{"path":"/articles/2-efficient-melting-unnesting.html","id":"github-users","dir":"Articles","previous_headings":"Nested list to data.frame > Bind to wide data.frame > Additional examples","what":"GitHub Users","title":"Efficient list melting and unnesting with rrapply","text":"","code":"library(repurrrsive)  ## nested data str(gh_users, list.len = 3) #> List of 6 #>  $ :List of 30 #>   ..$ login              : chr \"gaborcsardi\" #>   ..$ id                 : int 660288 #>   ..$ avatar_url         : chr \"https://avatars.githubusercontent.com/u/660288?v=3\" #>   .. [list output truncated] #>  $ :List of 30 #>   ..$ login              : chr \"jennybc\" #>   ..$ id                 : int 599454 #>   ..$ avatar_url         : chr \"https://avatars.githubusercontent.com/u/599454?v=3\" #>   .. [list output truncated] #>  $ :List of 30 #>   ..$ login              : chr \"jtleek\" #>   ..$ id                 : int 1571674 #>   ..$ avatar_url         : chr \"https://avatars.githubusercontent.com/u/1571674?v=3\" #>   .. [list output truncated] #>   [list output truncated]  ## unnested version rrapply(gh_users, how = \"bind\") |>   as_tibble() #> # A tibble: 6 × 30 #>   login     id avata…¹ grava…² url   html_…³ follo…⁴ follo…⁵ gists…⁶ starr…⁷ subsc…⁸ organ…⁹ repos…˟ event…˟ recei…˟ type  site_…˟ name  company blog  #>   <chr>  <int> <chr>   <chr>   <chr> <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr> <lgl>   <chr> <list>  <chr> #> 1 gabo… 6.60e5 https:… \"\"      http… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… User  FALSE   Gábo… <chr>   http… #> 2 jenn… 5.99e5 https:… \"\"      http… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… User  FALSE   Jenn… <chr>   http… #> 3 jtle… 1.57e6 https:… \"\"      http… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… User  FALSE   Jeff… <NULL>  http… #> 4 juli… 1.25e7 https:… \"\"      http… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… User  FALSE   Juli… <NULL>  juli… #> 5 leep… 3.51e6 https:… \"\"      http… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… User  FALSE   Thom… <chr>   http… #> 6 masa… 8.36e6 https:… \"\"      http… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… User  FALSE   Maël… <chr>   http… #> # … with 10 more variables: location <chr>, email <list>, hireable <list>, bio <list>, public_repos <int>, public_gists <int>, followers <int>, #> #   following <int>, created_at <chr>, updated_at <chr>, and abbreviated variable names ¹​avatar_url, ²​gravatar_id, ³​html_url, ⁴​followers_url, #> #   ⁵​following_url, ⁶​gists_url, ⁷​starred_url, ⁸​subscriptions_url, ⁹​organizations_url, ˟​repos_url, ˟​events_url, ˟​received_events_url, ˟​site_admin #> # ℹ Use `colnames()` to see all variable names"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"github-repos","dir":"Articles","previous_headings":"Nested list to data.frame > Bind to wide data.frame > Additional examples","what":"GitHub repos","title":"Efficient list melting and unnesting with rrapply","text":"","code":"## nested data str(gh_repos, list.len = 2) #> List of 6 #>  $ :List of 30 #>   ..$ :List of 68 #>   .. ..$ id               : int 61160198 #>   .. ..$ name             : chr \"after\" #>   .. .. [list output truncated] #>   ..$ :List of 68 #>   .. ..$ id               : int 40500181 #>   .. ..$ name             : chr \"argufy\" #>   .. .. [list output truncated] #>   .. [list output truncated] #>  $ :List of 30 #>   ..$ :List of 68 #>   .. ..$ id               : int 14756210 #>   .. ..$ name             : chr \"2013-11_sfu\" #>   .. .. [list output truncated] #>   ..$ :List of 68 #>   .. ..$ id               : int 14152301 #>   .. ..$ name             : chr \"2014-01-27-miami\" #>   .. .. [list output truncated] #>   .. [list output truncated] #>   [list output truncated]  ## unnested version rrapply(gh_repos, how = \"bind\") |>   as_tibble() #> # A tibble: 176 × 84 #>          id name       full_…¹ owner…² owner…³ owner…⁴ owner…⁵ owner…⁶ owner…⁷ owner…⁸ owner…⁹ owner…˟ owner…˟ owner…˟ owner…˟ owner…˟ owner…˟ owner…˟ #>       <int> <chr>      <chr>   <chr>     <int> <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   #>  1 61160198 after      gaborc… gaborc…  660288 https:… \"\"      https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… #>  2 40500181 argufy     gaborc… gaborc…  660288 https:… \"\"      https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… #>  3 36442442 ask        gaborc… gaborc…  660288 https:… \"\"      https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… #>  4 34924886 baseimpor… gaborc… gaborc…  660288 https:… \"\"      https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… #>  5 61620661 citest     gaborc… gaborc…  660288 https:… \"\"      https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… #>  6 33907457 clisymbols gaborc… gaborc…  660288 https:… \"\"      https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… #>  7 37236467 cmaker     gaborc… gaborc…  660288 https:… \"\"      https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… #>  8 67959624 cmark      gaborc… gaborc…  660288 https:… \"\"      https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… #>  9 63152619 conditions gaborc… gaborc…  660288 https:… \"\"      https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… #> 10 24343686 crayon     gaborc… gaborc…  660288 https:… \"\"      https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… https:… #> # … with 166 more rows, 66 more variables: owner.type <chr>, owner.site_admin <lgl>, private <lgl>, html_url <chr>, description <list>, fork <lgl>, #> #   url <chr>, forks_url <chr>, keys_url <chr>, collaborators_url <chr>, teams_url <chr>, hooks_url <chr>, issue_events_url <chr>, events_url <chr>, #> #   assignees_url <chr>, branches_url <chr>, tags_url <chr>, blobs_url <chr>, git_tags_url <chr>, git_refs_url <chr>, trees_url <chr>, #> #   statuses_url <chr>, languages_url <chr>, stargazers_url <chr>, contributors_url <chr>, subscribers_url <chr>, subscription_url <chr>, #> #   commits_url <chr>, git_commits_url <chr>, comments_url <chr>, issue_comment_url <chr>, contents_url <chr>, compare_url <chr>, merges_url <chr>, #> #   archive_url <chr>, downloads_url <chr>, issues_url <chr>, pulls_url <chr>, milestones_url <chr>, notifications_url <chr>, labels_url <chr>, #> #   releases_url <chr>, deployments_url <chr>, created_at <chr>, updated_at <chr>, pushed_at <chr>, git_url <chr>, ssh_url <chr>, clone_url <chr>, … #> # ℹ Use `print(n = ...)` to see more rows, and `colnames()` to see all variable names"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"game-of-thrones-characters","dir":"Articles","previous_headings":"Nested list to data.frame > Bind to wide data.frame > Additional examples","what":"Game of Thrones characters","title":"Efficient list melting and unnesting with rrapply","text":"","code":"## nested data str(got_chars, list.len = 3) #> List of 30 #>  $ :List of 18 #>   ..$ url        : chr \"https://www.anapioficeandfire.com/api/characters/1022\" #>   ..$ id         : int 1022 #>   ..$ name       : chr \"Theon Greyjoy\" #>   .. [list output truncated] #>  $ :List of 18 #>   ..$ url        : chr \"https://www.anapioficeandfire.com/api/characters/1052\" #>   ..$ id         : int 1052 #>   ..$ name       : chr \"Tyrion Lannister\" #>   .. [list output truncated] #>  $ :List of 18 #>   ..$ url        : chr \"https://www.anapioficeandfire.com/api/characters/1074\" #>   ..$ id         : int 1074 #>   ..$ name       : chr \"Victarion Greyjoy\" #>   .. [list output truncated] #>   [list output truncated]  ## unnested version rrapply(got_chars, how = \"bind\") |>   as_tibble() #> # A tibble: 30 × 18 #>    url                             id name  gender culture born  died  alive titles aliases father mother spouse alleg…¹ books povBo…² tvSer…³ playe…⁴ #>    <chr>                        <int> <chr> <chr>  <chr>   <chr> <chr> <lgl> <list> <list>  <chr>  <chr>  <chr>  <list>  <lis> <list>  <list>  <list>  #>  1 https://www.anapioficeandfi…  1022 Theo… Male   \"Ironb… \"In … \"\"    TRUE  <chr>  <chr>   \"\"     \"\"     \"\"     <chr>   <chr> <chr>   <chr>   <chr>   #>  2 https://www.anapioficeandfi…  1052 Tyri… Male   \"\"      \"In … \"\"    TRUE  <chr>  <chr>   \"\"     \"\"     \"http… <chr>   <chr> <chr>   <chr>   <chr>   #>  3 https://www.anapioficeandfi…  1074 Vict… Male   \"Ironb… \"In … \"\"    TRUE  <chr>  <chr>   \"\"     \"\"     \"\"     <chr>   <chr> <chr>   <chr>   <chr>   #>  4 https://www.anapioficeandfi…  1109 Will  Male   \"\"      \"\"    \"In … FALSE <chr>  <chr>   \"\"     \"\"     \"\"     <lgl>   <chr> <chr>   <chr>   <chr>   #>  5 https://www.anapioficeandfi…  1166 Areo… Male   \"Norvo… \"In … \"\"    TRUE  <chr>  <chr>   \"\"     \"\"     \"\"     <chr>   <chr> <chr>   <chr>   <chr>   #>  6 https://www.anapioficeandfi…  1267 Chett Male   \"\"      \"At … \"In … FALSE <chr>  <chr>   \"\"     \"\"     \"\"     <lgl>   <chr> <chr>   <chr>   <chr>   #>  7 https://www.anapioficeandfi…  1295 Cres… Male   \"\"      \"In … \"In … FALSE <chr>  <chr>   \"\"     \"\"     \"\"     <lgl>   <chr> <chr>   <chr>   <chr>   #>  8 https://www.anapioficeandfi…   130 Aria… Female \"Dorni… \"In … \"\"    TRUE  <chr>  <chr>   \"\"     \"\"     \"\"     <chr>   <chr> <chr>   <chr>   <chr>   #>  9 https://www.anapioficeandfi…  1303 Daen… Female \"Valyr… \"In … \"\"    TRUE  <chr>  <chr>   \"\"     \"\"     \"http… <chr>   <chr> <chr>   <chr>   <chr>   #> 10 https://www.anapioficeandfi…  1319 Davo… Male   \"Weste… \"In … \"\"    TRUE  <chr>  <chr>   \"\"     \"\"     \"http… <chr>   <chr> <chr>   <chr>   <chr>   #> # … with 20 more rows, and abbreviated variable names ¹​allegiances, ²​povBooks, ³​tvSeries, ⁴​playedBy #> # ℹ Use `print(n = ...)` to see more rows"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"sharla-gelfands-discography","dir":"Articles","previous_headings":"Nested list to data.frame > Bind to wide data.frame > Additional examples","what":"Sharla Gelfand’s discography","title":"Efficient list melting and unnesting with rrapply","text":"","code":"## nested data (first element) str(discog[1], list.len = 3) #> List of 1 #>  $ :List of 5 #>   ..$ instance_id      : int 354823933 #>   ..$ date_added       : chr \"2019-02-16T17:48:59-08:00\" #>   ..$ basic_information:List of 11 #>   .. ..$ labels      :List of 1 #>   .. .. ..$ :List of 6 #>   .. .. .. ..$ name            : chr \"Tobi Records (2)\" #>   .. .. .. ..$ entity_type     : chr \"1\" #>   .. .. .. ..$ catno           : chr \"TOB-013\" #>   .. .. .. .. [list output truncated] #>   .. ..$ year        : int 2015 #>   .. ..$ master_url  : NULL #>   .. .. [list output truncated] #>   .. [list output truncated]  ## unnested version (excluding deeply nested sublists) discs <- rrapply(   discog,   condition = \\(x, .xpos) length(.xpos) < 5,   f = \\(x) ifelse(is.null(x), NA, x),  ## replace NULLs   how = \"bind\" ) as_tibble(discs) #> # A tibble: 155 × 12 #>    instance_id date_added                basic_information.year basic_information.mast…¹ basic…² basic…³ basic…⁴ basic…⁵ basic…⁶ basic…⁷     id rating #>          <int> <chr>                                      <int> <chr>                      <int> <chr>   <chr>   <chr>   <chr>     <int>  <int>  <int> #>  1   354823933 2019-02-16T17:48:59-08:00                   2015 NA                        7.50e6 \"https… Demo    https:… https:…       0 7.50e6      0 #>  2   354092601 2019-02-13T14:13:11-08:00                   2013 https://api.discogs.com…  4.49e6 \"https… Observ… https:… https:…  553057 4.49e6      0 #>  3   354091476 2019-02-13T14:07:23-08:00                   2017 https://api.discogs.com…  9.83e6 \"https… I       https:… https:… 1109943 9.83e6      0 #>  4   351244906 2019-02-02T11:39:58-08:00                   2017 https://api.discogs.com…  9.77e6 \"https… Oído A… https:… https:… 1128934 9.77e6      0 #>  5   351244801 2019-02-02T11:39:37-08:00                   2015 https://api.discogs.com…  7.24e6 \"https… A Cat'… https:… https:…  857592 7.24e6      0 #>  6   351052065 2019-02-01T20:40:53-08:00                   2019 https://api.discogs.com…  1.31e7 \"https… Tashme  https:… https:… 1498137 1.31e7      0 #>  7   350315345 2019-01-29T15:48:37-08:00                   2014 https://api.discogs.com…  7.11e6 \"https… Demo    https:… https:…  852880 7.11e6      0 #>  8   350315103 2019-01-29T15:47:22-08:00                   2015 https://api.discogs.com…  1.05e7 \"https… Let Th… https:… https:…  869410 1.05e7      0 #>  9   350314507 2019-01-29T15:44:08-08:00                   2017 https://api.discogs.com…  1.13e7 \"\"      Sub Sp… https:… https:… 1281224 1.13e7      0 #> 10   350314047 2019-01-29T15:41:35-08:00                   2017 NA                        1.17e7 \"https… Demo    https:… https:…       0 1.17e7      0 #> # … with 145 more rows, and abbreviated variable names ¹​basic_information.master_url, ²​basic_information.id, ³​basic_information.thumb, #> #   ⁴​basic_information.title, ⁵​basic_information.cover_image, ⁶​basic_information.resource_url, ⁷​basic_information.master_id #> # ℹ Use `print(n = ...)` to see more rows  ## unnest labels sublists  labels <- rrapply(   discog,   condition = \\(x, .xparents) \"labels\" %in% .xparents,   how = \"bind\",   options = list(coldepth = 5, namecols = TRUE) ) as_tibble(labels) #> # A tibble: 182 × 10 #>    L1    L2                L3     L4    name                                      entity_type catno   resource_url                          id entit…¹ #>    <chr> <chr>             <chr>  <chr> <chr>                                     <chr>       <chr>   <chr>                              <int> <chr>   #>  1 1     basic_information labels 1     Tobi Records (2)                          1           TOB-013 https://api.discogs.com/labels/6… 633407 Label   #>  2 2     basic_information labels 1     La Vida Es Un Mus                         1           Mus70   https://api.discogs.com/labels/3…  38322 Label   #>  3 3     basic_information labels 1     La Vida Es Un Mus                         1           MUS118  https://api.discogs.com/labels/3…  38322 Label   #>  4 4     basic_information labels 1     La Vida Es Un Mus                         1           MUS132  https://api.discogs.com/labels/3…  38322 Label   #>  5 4     basic_information labels 2     Beat Generation                           1           BEAT64  https://api.discogs.com/labels/8…  88198 Label   #>  6 4     basic_information labels 3     Beat Generation                           1           BEAT 64 https://api.discogs.com/labels/8…  88198 Label   #>  7 5     basic_information labels 1     Katorga Works                             1           KW-043  https://api.discogs.com/labels/2… 205895 Label   #>  8 6     basic_information labels 1     High Fashion Industries                   1           HFI017  https://api.discogs.com/labels/6… 637837 Label   #>  9 7     basic_information labels 1     Mind Control Records (6)                  1           none    https://api.discogs.com/labels/7… 763103 Label   #> 10 8     basic_information labels 1     Not On Label (Phantom Head Self-released) 1           none    https://api.discogs.com/labels/8… 879916 Label   #> # … with 172 more rows, and abbreviated variable name ¹​entity_type_name #> # ℹ Use `print(n = ...)` to see more rows  ## merge disc id's with labels merge(   x = data.frame(L1 = rownames(discs), disc_id = discs[, \"id\"]),   y = labels,    by = \"L1\",    sort = FALSE ) |>   as_tibble() #> # A tibble: 182 × 11 #>    L1     disc_id L2                L3     L4    name                                      entity_type catno   resource_url                 id entit…¹ #>    <chr>    <int> <chr>             <chr>  <chr> <chr>                                     <chr>       <chr>   <chr>                     <int> <chr>   #>  1 1      7496378 basic_information labels 1     Tobi Records (2)                          1           TOB-013 https://api.discogs.com… 633407 Label   #>  2 2      4490852 basic_information labels 1     La Vida Es Un Mus                         1           Mus70   https://api.discogs.com…  38322 Label   #>  3 3      9827276 basic_information labels 1     La Vida Es Un Mus                         1           MUS118  https://api.discogs.com…  38322 Label   #>  4 4      9769203 basic_information labels 1     La Vida Es Un Mus                         1           MUS132  https://api.discogs.com…  38322 Label   #>  5 4      9769203 basic_information labels 2     Beat Generation                           1           BEAT64  https://api.discogs.com…  88198 Label   #>  6 4      9769203 basic_information labels 3     Beat Generation                           1           BEAT 64 https://api.discogs.com…  88198 Label   #>  7 5      7237138 basic_information labels 1     Katorga Works                             1           KW-043  https://api.discogs.com… 205895 Label   #>  8 6     13117042 basic_information labels 1     High Fashion Industries                   1           HFI017  https://api.discogs.com… 637837 Label   #>  9 7      7113575 basic_information labels 1     Mind Control Records (6)                  1           none    https://api.discogs.com… 763103 Label   #> 10 8     10540713 basic_information labels 1     Not On Label (Phantom Head Self-released) 1           none    https://api.discogs.com… 879916 Label   #> # … with 172 more rows, and abbreviated variable name ¹​entity_type_name #> # ℹ Use `print(n = ...)` to see more rows"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"data-frame-to-nested-list","dir":"Articles","previous_headings":"","what":"Data.frame to nested list","title":"Efficient list melting and unnesting with rrapply","text":"demonstrating example, reconsider long data.frame first section obtained melting renewable energy shares Western European countries: certain tasks, may necessary convert data.frame back nested list object, e.g. write data JSON- XML-object tree visualization purpose. Writing recursive function reconstruct nested list can prove quite time-consuming error-prone. context, unlist() function inverse counterpart relist() reconstructs nested list unlisted vector. relist() function always requires skeleton nested list repopulate, can make difficult use practice, skeleton object instance unavailable current example. particular, melted data.frame contains subset original list elements, can use original list template object without filtering nodes original list well.","code":"renewable_energy_melt_west_eu <- rrapply(   renewable_energy_by_country,   condition = \\(x, .xparents) \"Western Europe\" %in% .xparents,   how = \"melt\" )  head(renewable_energy_melt_west_eu, n = 10) #>      L1     L2             L3            L4 value #> 1 World Europe Western Europe       Austria 34.67 #> 2 World Europe Western Europe       Belgium  9.14 #> 3 World Europe Western Europe        France 14.74 #> 4 World Europe Western Europe       Germany 14.17 #> 5 World Europe Western Europe Liechtenstein 62.93 #> 6 World Europe Western Europe    Luxembourg 13.54 #> 7 World Europe Western Europe        Monaco    NA #> 8 World Europe Western Europe   Netherlands  5.78 #> 9 World Europe Western Europe   Switzerland 25.49"},{"path":"/articles/2-efficient-melting-unnesting.html","id":"unmelt-to-nested-list","dir":"Articles","previous_headings":"Data.frame to nested list","what":"Unmelt to nested list","title":"Efficient list melting and unnesting with rrapply","text":"address difficulty, rrapply() includes dedicated option = \"unmelt\" performs inverse operation = \"melt\". skeleton object needed case, plain data.frame format returned = \"melt\". illustrate, can convert melted data.frame nested list follows: Remark 1: = \"unmelt\" based greedy approach parsing data.frame rows list elements starting top data.frame. , rrapply() continues collecting children nodes long parent node name remains unchanged. , instance, goal create two separate nodes (level) name \"Western Europe\", nodes listed directly one another melted data.frame rrapply() group children single \"Western Europe\" list element. Remark 2: Internally, = \"unmelt\" reconstructs nested list melted data.frame subsequently follows conceptual framework = \"replace\". function arguments, f condition can used exactly way applying = \"replace\" nested list object. Remark 3: = \"unmelt\" (currently) restore attributes intermediate list nodes therefore exact inverse = \"melt\". way around always produces result: terms computational effort, rrapply()’s = \"unmelt\" can equally efficient relist() even though template list object can repopulated. highlighted using large list objects generated previously: Note: unmelted lists exactly identical original nested lists, since = \"unmelt\" uses placeholder names 1, 2, 3, etc. melted data.frames name nodes newly constructed lists, whereas name attributes original lists empty. removing names unmelted lists, become identical original counterparts:","code":"rrapply(   renewable_energy_melt_west_eu,    how = \"unmelt\" ) |>   str(give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 1 #>   .. ..$ Western Europe:List of 9 #>   .. .. ..$ Austria      : num 34.7 #>   .. .. ..$ Belgium      : num 9.14 #>   .. .. ..$ France       : num 14.7 #>   .. .. ..$ Germany      : num 14.2 #>   .. .. ..$ Liechtenstein: num 62.9 #>   .. .. ..$ Luxembourg   : num 13.5 #>   .. .. ..$ Monaco       : num NA #>   .. .. ..$ Netherlands  : num 5.78 #>   .. .. ..$ Switzerland  : num 25.5 renewable_energy_unmelt <- rrapply(renewable_energy_melt_west_eu, how = \"unmelt\") renewable_energy_remelt <- rrapply(renewable_energy_unmelt, how = \"melt\")  identical(renewable_energy_melt_west_eu, renewable_energy_remelt) #> [1] TRUE ## large deeply nested list (2^18 elements) ##  benchmark timing with rrapply system.time(deep_unmelt <- rrapply(deep_melt, how = \"unmelt\"))  #>    user  system elapsed  #>   0.145   0.000   0.144  ## benchmark timing with relist deep_unlist <- unlist(as.relistable(deep_list)) system.time(deep_relist <- relist(deep_unlist)) #>    user  system elapsed  #>   3.026   0.000   3.026 ## large shallow list (10^6 elements) ## benchmark timing with rrapply  system.time(shallow_unmelt <- rrapply(shallow_melt, how = \"unmelt\"))  #>    user  system elapsed  #>   0.094   0.000   0.095  ## benchmark timing with relist shallow_unlist <- unlist(as.relistable(shallow_list)) system.time(shallow_relist <- relist(shallow_unlist)) #>    user  system elapsed  #>   5.344   0.000   5.344 ## remove all list names deep_unmelt_unnamed <- rrapply(   deep_unmelt,   f = unname,   classes = \"list\",   how = \"recurse\" ) ## check if identical identical(unname(deep_unmelt_unnamed), deep_list) #> [1] TRUE ## remove all list names shallow_unmelt_unnamed <- rrapply(   shallow_unmelt,   f = unname,   classes = \"list\",   how = \"recurse\" ) ## check if identical identical(unname(shallow_unmelt_unnamed), shallow_list) #> [1] TRUE"},{"path":"/articles/3-calls-and-expressions.html","id":"expressions","dir":"Articles","previous_headings":"","what":"Expressions","title":"Recursive apply for calls and expressions","text":"Unevaluated R code always parsed captured set expressions, collective term used refer following object types: scalar constants e.g. TRUE 1, symbols e.g. quote(x), call objects e.g. quote(x <- 1), expression vectors e.g. expression(<- 1, 2 * b) pairlists e.g. formals(seq.default). Call objects expression vectors hierarchically structured objects (also called abstract syntax trees) can decomposed symbols scalar constants atomic building blocks. See also chapter https://adv-r.hadley.nz/expressions.html general introduction expressions abstract syntax trees. Call objects expression vectors generally behave nested lists, e.g. subsetting call object achieved way subsetting nested list. illustrate, can retrieve abstract syntax tree call object recursing object way nested list: Given information, perhaps expected base rapply() also recurses call objects expression vectors way nested lists, unfortunately case. precise, rapply() accept expression vectors inputs, effectively treats objects flat lists call objects similar lapply(). Call objects accepted rapply() return error.","code":"## recurse through call as nested list ast <- function(expr) {   lapply(expr, function(x) {     if(is.call(x) || is.expression(x)) {       ast(x)      } else {       x     }   }) }  ## decompose call object str(ast(quote(y <- x <- 1 + TRUE))) #> List of 3 #>  $ : symbol <- #>  $ : symbol y #>  $ :List of 3 #>   ..$ : symbol <- #>   ..$ : symbol x #>   ..$ :List of 3 #>   .. ..$ : symbol + #>   .. ..$ : num 1 #>   .. ..$ : logi TRUE ## rapply on an expression vector rapply(expression(y <- x <- 1, f(g(2 * pi))), f = identity) #> [[1]] #> y <- x <- 1 #>  #> [[2]] #> f(g(2 * pi))  ## lapply on an expression vector lapply(expression(y <- x <- 1, f(g(2 * pi))), FUN = identity) #> [[1]] #> y <- x <- 1 #>  #> [[2]] #> f(g(2 * pi))  ## rapply on a call object (not ok!)  rapply(quote(y <- x <- 1), f = identity) #> Error in rapply(quote(y <- x <- 1), f = identity): 'object' must be a list or expression"},{"path":"/articles/3-calls-and-expressions.html","id":"expressions-and-rrapply","dir":"Articles","previous_headings":"","what":"Expressions and rrapply()","title":"Recursive apply for calls and expressions","text":"Starting version 1.2.0, rrapply() also supports recursion call objects expression vectors, treated nested lists based internal abstract syntax trees. , functionality described vignette(\"1---use-rrapply\") extends directly call objects expression vectors.","code":""},{"path":"/articles/3-calls-and-expressions.html","id":"structuring-the-result","dir":"Articles","previous_headings":"Expressions and rrapply()","what":"Structuring the result","title":"Recursive apply for calls and expressions","text":"applying rrapply() (base rapply()) nested lists difference = \"replace\" = \"list\" relatively minor. choices return nested list, = \"list\" replaces elements subject f argument deflt. call objects expression objects, difference important = \"replace\" always maintains type object application rrapply(), whereas = \"list\" returns object formatted nested list. = \"replace\", can instance directly update abstract syntax tree call object: Using = \"list\", can update abstract syntax tree return nested list: Remark: second function call use classes = \"logical\" avoid list elements class \"logical\" replaced deflt argument (NULL). choices = \"prune\", = \"flatten\" = \"melt\" return pruned abstract syntax tree : nested list, flattened vector list melted data.frame respectively. identical application rrapply() abstract syntax tree formatted nested list. illustrate, let us return names abstract syntax tree expression vector part base R.","code":"library(rrapply)  call_obj <- quote(y <- x <- 1 + TRUE) str(call_obj) #>  language y <- x <- 1 + TRUE  ## update call object rrapply(   call_obj,    classes = \"logical\",    f = as.numeric,    how = \"replace\" ) |>   str() #>  language y <- x <- 1 + 1 ## update and decompose call object rrapply(   call_obj,    f = \\(x) ifelse(is.logical(x), as.numeric(x), x),    how = \"list\" ) |>   str() #> List of 3 #>  $ : symbol <- #>  $ : symbol y #>  $ :List of 3 #>   ..$ : symbol <- #>   ..$ : symbol x #>   ..$ :List of 3 #>   .. ..$ : symbol + #>   .. ..$ : num 1 #>   .. ..$ : num 1 ## example expression expr <- expression(y <- x <- 1, f(g(2 * pi))) ## check if name is not in base environment is_new_name <- \\(x) !exists(as.character(x), envir = baseenv())  ## prune and decompose expression rrapply(   expr,    classes = \"name\",    condition = is_new_name,    how = \"prune\" ) |>   str() #> List of 2 #>  $ :List of 2 #>   ..$ : symbol y #>   ..$ :List of 1 #>   .. ..$ : symbol x #>  $ :List of 2 #>   ..$ : symbol f #>   ..$ :List of 1 #>   .. ..$ : symbol g  ## prune and flatten expression rrapply(   expr,    classes = \"name\",    condition = is_new_name,    how = \"flatten\" ) |>   str() #> List of 4 #>  $ : symbol y #>  $ : symbol x #>  $ : symbol f #>  $ : symbol g  ## prune and melt expression rrapply(   expr,    classes = \"name\",    condition = is_new_name,    how = \"melt\" ) #>   L1 L2   L3 value #> 1  1  2 <NA>     y #> 2  1  3    2     x #> 3  2  1 <NA>     f #> 4  2  2    1     g"},{"path":"/articles/3-calls-and-expressions.html","id":"avoid-recursing-into-expressions","dir":"Articles","previous_headings":"Expressions and rrapply()","what":"Avoid recursing into expressions","title":"Recursive apply for calls and expressions","text":"classes = \"\" (default), rrapply() recurses list-like element, expression objects : call objects, expression vectors pairlists. avoid recursing list elements nested list, can use classes = \"list\". Analogously, avoid recursing list-like elements abstract syntax tree, use classes = \"language\", classes = \"expression\", classes = \"pairlist\" combination thereof. condition classes arguments satisfied given list-like element, rrapply() recurse object, apply f function nodes satisfy condition classes . Note behavior can triggered classes argument use e.g. condition = .call. illustrate, extract deeply nested call objects example expression return flat list:","code":"## extract all terminal call nodes of AST rrapply(   expr,    classes = \"language\",    condition = \\(x) !any(sapply(x, is.call)),   how = \"flatten\" ) #> [[1]] #> x <- 1 #>  #> [[2]] #> 2 * pi"},{"path":"/articles/3-calls-and-expressions.html","id":"additional-examples","dir":"Articles","previous_headings":"Expressions and rrapply()","what":"Additional examples","title":"Recursive apply for calls and expressions","text":"section provides several worked code examples using rrapply() recurse abstract syntax tree call object, mainly inspired codetools package chapter https://adv-r.hadley.nz/expressions.html#ast-funs. Note examples can also rewritten using recursive function definitions base R, use rrapply() makes code quite concise straightforward follow. examples ordered increasing degrees code complexity.","code":""},{"path":"/articles/3-calls-and-expressions.html","id":"example-1-replacing-t-and-f","dir":"Articles","previous_headings":"Expressions and rrapply() > Additional examples","what":"Example 1: Replacing T and F","title":"Recursive apply for calls and expressions","text":"https://adv-r.hadley.nz/expressions.html#ast-funs, demonstrate recursion abstract syntax tree expression, recursive function logical_abbr() defined check presence logical abbreviations T F expression object: Let us revisit example find, also replace logical abbreviations non-abbreviated counterparts. Using rrapply(), set = \"replace\" order maintain original object type updating abstract syntax tree:","code":"## recursive function to check for T or F logical_abbr <- function(x) {   if (is.atomic(x)) {     FALSE   } else if (is.name(x)) {     identical(x, quote(T)) || identical(x, quote(F))   } else if (is.call(x) || is.pairlist(x)) {     for (i in seq_along(x)) {       if (logical_abbr(x[[i]])) return(TRUE)     }     FALSE   } else {     stop(\"Don't know how to handle type \", typeof(x),           call. = FALSE)   } }  call1 <- quote(mean(x, na.rm = T)) call2 <- quote(f(x = c(TRUE, FALSE)))  ## containing a logical abbreviation logical_abbr(call1) #> [1] TRUE ## not containing a logical abbreviation logical_abbr(call2) #> [1] FALSE ## expand logical abbreviation logical_abbr_expand <- function(x) {   if(identical(x, quote(T))) {     TRUE   } else if(identical(x, quote(F))) {     FALSE   } else {     x   } }  call3 <- expression(f(x = c(T, F)), any(T, FALSE))  rrapply(call1, f = logical_abbr_expand, how = \"replace\") #> mean(x, na.rm = TRUE) rrapply(call3, f = logical_abbr_expand, how = \"replace\") #> expression(f(x = c(TRUE, FALSE)), any(TRUE, FALSE))"},{"path":"/articles/3-calls-and-expressions.html","id":"example-2-finding-local-variables","dir":"Articles","previous_headings":"Expressions and rrapply() > Additional examples","what":"Example 2: Finding local variables","title":"Recursive apply for calls and expressions","text":"second demonstrating example abstract syntax tree recursion https://adv-r.hadley.nz/expressions.html#ast-funs deals finding variables expression created assignment. recursive function find_assign() finds variables created assignment <- returns character vector: Revisiting example using rrapply(), essentially need filter name (.e. symbol) second element call <-. Checking position element call can done .xpos argument. verify first element call actual assignment, can make use .xsiblings argument. slightly generalize find_assign() function also return variables created =, , assign delayedAssign.","code":"find_assign <- function(x) {   if (is.atomic(x) || is.name(x)) {     character()   } else if (is.call(x)) {     if (identical(x[[1]], quote(`<-`)) && is.name(x[[2]])) {       lhs <- as.character(x[[2]])     } else {       lhs <- character()     }     unique(c(lhs, unlist(lapply(x, find_assign))))   } else if (is.pairlist(x)) {     unique(unlist(lapply(x, find_assign)))   } else {     stop(\"Don't know how to handle type \", typeof(x), call. = FALSE)   } }  call4 <- quote({   l <- list()   l$a <- 5   names(l) <- \"b\" })  find_assign(call4) #> [1] \"l\" ## helper function to check if variable is created by assignment is_assign <- function(x, .xpos, .xsiblings) {   ## element is second in call   tail(.xpos, 1) == 2 &&     ## first element in call is assignment     as.character(.xsiblings[[1]]) %in% c(\"<-\", \"=\", \"for\", \"assign\", \"delayedAssign\") }  rrapply(call4, condition = is_assign, f = as.character, how = \"unlist\") #> [1] \"l\""},{"path":"/articles/3-calls-and-expressions.html","id":"example-3-finding-global-variables","dir":"Articles","previous_headings":"Expressions and rrapply() > Additional examples","what":"Example 3: Finding global variables","title":"Recursive apply for calls and expressions","text":"codetools package contains findGlobals() find global variables used function. Building previous example, can construct (simplified) version findGlobals() searching variable body function local variable function argument. precisely, collect variable names global variables character vector exclude. includes: function arguments; variables created assignment previous example; package names used :: ::: (e.g. stats stats::lm()); variable names used $ @ (e.g. x$list x@S4-object). recurse abstract syntax tree similar previous example discarding variable names elements exclude part base environment (.e. baseenv()). remaining global variables returned character vector. Remark: sake simplicity completely rigorous example. instance, function arguments inline functions excluded set global variables. Also, variable names created assign() delayedAssign() assigned e.g. .GlobalEnv, case arguably recognized global variables. illustrate newly defined function find_globals(), let us apply rrapply() function : C_unmelt() C_rrapply() internal workhorses rrapply() part rrapply-package. default, codetools findGlobals() function also returns variable names base package. Discarding names present base package findGlobals() produces result find_globals(): Several additional comparisons find_globals() findGlobals2() applied common R functions:","code":"## helper function to check for non-global variables is_exclude <-function(x, .xpos, .xsiblings) {   operator <- as.character(.xsiblings[[1]])   if(tail(.xpos, 1) == 2) {     operator %in% c(\"<-\", \"=\", \"for\", \"assign\", \"delayedAssign\", \"::\", \":::\")   } else if(tail(.xpos, 1) == 3) {     operator %in% c(\"@\", \"$\")   } else {     FALSE    } }  ## helper function to check for global variables is_global <- function(x, exclude) {   xvar <- as.character(x)   ## non-empty element not in exclude or base environment   nzchar(xvar) &&      !xvar %in% exclude &&      !exists(xvar, envir = baseenv()) }  find_globals <- function(fun) {   ## find local variables to exclude   exclude <- rrapply(body(fun), condition = is_exclude, f = as.character, how = \"unlist\")   exclude <- c(names(formals(fun)), exclude)   ## find global variables                globals <- rrapply(body(fun), classes = \"name\", condition = is_global, f = as.character, exclude = exclude, how = \"unlist\")   return(unique(globals)) } find_globals(rrapply) #> [1] \"C_unmelt\"  \"C_rrapply\" ## update existing findGlobals function findGlobals2 <- function(fun, merge = TRUE) {   globals <- codetools::findGlobals(fun, merge = merge)   globals[sapply(globals, Negate(exists), envir = baseenv())] }  findGlobals2(rrapply) #> [1] \"C_rrapply\" \"C_unmelt\" ## par is part of formals(plot.default) find_globals(plot.default) #> [1] \"Axis\"        \"box\"         \"plot.window\" \"title\"       \"xy.coords\"   #> [6] \"dev.hold\"    \"dev.flush\"   \"plot.new\"    \"plot.xy\" findGlobals2(plot.default) #>  [1] \"Axis\"        \"box\"         \"dev.flush\"   \"dev.hold\"    \"par\"         #>  [6] \"plot.new\"    \"plot.window\" \"plot.xy\"     \"title\"       \"xy.coords\"  ## model.frame is called as stats::model.frame find_globals(lm) #> [1] \"model.frame\"    \"model.response\" \"model.weights\"  \"model.offset\"   #> [5] \"is.empty.model\" \"model.matrix\"   \"lm.fit\"         \"lm.wfit\"        #> [9] \".getXlevels\" findGlobals2(lm) #> [1] \".getXlevels\"    \"is.empty.model\" \"lm.fit\"         \"lm.wfit\"        #> [5] \"model.matrix\"   \"model.offset\"   \"model.response\" \"model.weights\"  ## parallel functions are called as parallel::... find_globals(boot::boot) #>  [1] \"runif\"               \"empinf\"              \"isMatrix\"            #>  [4] \"normalize\"           \"index.array\"         \"freq.array\"          #>  [7] \"mclapply\"            \"makePSOCKcluster\"    \"clusterSetRNGStream\" #> [10] \"parLapply\"           \"stopCluster\"         \"boot.return\" findGlobals2(boot::boot) #> [1] \"boot.return\" \"empinf\"      \"freq.array\"  \"index.array\" \"isMatrix\"    #> [6] \"normalize\"   \"runif\""},{"path":"/articles/3-calls-and-expressions.html","id":"example-4-plot-abstract-syntax-tree-as-dendrogram","dir":"Articles","previous_headings":"Expressions and rrapply() > Additional examples","what":"Example 4: Plot abstract syntax tree as dendrogram","title":"Recursive apply for calls and expressions","text":"conclude, let us consider plotting abstract syntax trees dendrograms. Base R includes plot() method dendrogram objects, therefore suffices write function allows convert expression objects dendrogram objects. turns dendrogram object defined nested list specific attributes list component turn dendrogram. seen previously, can convert abstract syntax tree expression object nested list rrapply() setting = \"list\". addition, need recurse nested list add dendrogram specific attributes. achieve single node, define separate helper function add_dend_attrs() distinguishes branch (.e. list) nodes leaf nodes abstract syntax tree. height attribute add_dend_attrs() calculated function depth node evaluation overall maximum depth abstract syntax tree. first can obtained via special argument .xpos, second evaluated recursing abstract syntax tree call rrapply(). apply add_dend_attrs() (terminal non-terminal) node nested list, set classes = c(\"list\", \"\") = \"recurse\" second call rrapply() explained vignette(\"1---use-rrapply\"). test defined function, provide call object body rrapply() function pass expr_to_dend() convert dendrogram:","code":"## helper function to add dendrogram attributes add_dend_attrs <- function(x, .xpos, maxdepth) {   if(is.list(x)) {     x <- rev(x)     members <- length(unlist(x))     attributes(x) <- list(       members = members,        midpoints = members - 1     )   } else {     x <- ifelse(!is.null(x), as.character(x), \"NULL\")     attributes(x) <- list(       label = x,        members = 1,        leaf = TRUE     )   }   attr(x, \"height\") <- 1 + (1 - length(.xpos)) / maxdepth   return(x) }  ## convert expression to dendrogram expr_to_dend <- function(expr) {   ## update maximum depth by assigning to surrounding scope   maxdepth <- integer(1)   dend1 <- rrapply(expr, f = function(x, .xpos) { if(length(.xpos) > maxdepth) maxdepth <<- length(.xpos); x }, how = \"list\")   ## recursively update attributes of each node   dend2 <- rrapply(list(dend1), classes = c(\"list\", \"ANY\"), f = add_dend_attrs, maxdepth = maxdepth, how = \"recurse\")[[1]]   class(dend2) <- \"dendrogram\"   return(dend2) } ## plot abstract syntax tree as dendrogram  (rrapply_dend <- expr_to_dend(body(rrapply))) #> 'dendrogram' with 18 branches and 461 members total, at height 1 plot(rrapply_dend, horiz = TRUE, type = \"triangle\", yaxt = \"n\")"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Joris Chau. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chau J (2022). rrapply: Revisiting Base Rapply. https://jorischau.github.io/rrapply/, https://github.com/JorisChau/rrapply.","code":"@Manual{,   title = {rrapply: Revisiting Base Rapply},   author = {Joris Chau},   year = {2022},   note = {https://jorischau.github.io/rrapply/, https://github.com/JorisChau/rrapply}, }"},{"path":"/index.html","id":"rrapply-revisiting-r-base-rapply-","dir":"","previous_headings":"","what":"Revisiting Base Rapply","title":"Revisiting Base Rapply","text":"minimal {rrapply}-package contains single function rrapply(), providing extended implementation R-base’s rapply() function, applies function f elements nested list recursively controls structure returned result. rrapply() builds upon rapply()’s native C implementation reason requires external R-package dependencies.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Revisiting Base Rapply","text":"","code":"# Install latest release from CRAN: install.packages(\"rrapply\")  # Install the development version from GitHub: # install.packages(\"devtools\") devtools::install_github(\"JorisChau/rrapply\")"},{"path":[]},{"path":[]},{"path":[]},{"path":"/index.html","id":"id_-how--prune","dir":"","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"• how = \"prune\"","title":"Revisiting Base Rapply","text":"base rapply(), convenient way prune filter list elements input list object. rrapply() function adds option = \"prune\" prune list elements subject application f nested list,","code":"library(rrapply)  ## data: renewable energy per country in 2016 (% of total energy consumption) data(\"renewable_energy_by_country\")  ## subset countries and areas in Oceania renewable_oceania <- renewable_energy_by_country[[\"World\"]][\"Oceania\"] str(renewable_oceania, list.len = 3, give.attr = FALSE)  #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : logi NA #>   .. ..$ Cocos (Keeling) Islands          : logi NA #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated] ## drop all logical NA's while preserving list structure  rrapply(   renewable_oceania,   f = \\(x) x,   classes = \"numeric\",   how = \"prune\" ) |>   str(list.len = 3, give.attr = FALSE)  #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/index.html","id":"id_-how--flatten","dir":"","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"• how = \"flatten\"","title":"Revisiting Base Rapply","text":"Instead, use = \"flatten\" return flattened unnested version pruned list, Hint: options argument allows avoid coercion flattened list vector /include parent list names result.","code":"## drop all logical NA's and return unnested list rrapply(   renewable_oceania,   f = \\(x) x,   classes = \"numeric\",   how = \"flatten\" ) |>   head(n = 10)  #>        Australia      New Zealand             Fiji    New Caledonia  #>             9.32            32.76            24.36             4.03  #> Papua New Guinea  Solomon Islands          Vanuatu             Guam  #>            50.34            65.73            33.67             3.03  #>         Kiribati Marshall Islands  #>            45.43            11.75 ## flatten to simple list with full names rrapply(   renewable_oceania,   f = \\(x) x,   classes = \"numeric\",   how = \"flatten\",   options = list(namesep = \".\", simplify = FALSE) ) |>   str(list.len = 5, give.attr = FALSE)  #> List of 22 #>  $ Oceania.Australia and New Zealand.Australia        : num 9.32 #>  $ Oceania.Australia and New Zealand.New Zealand      : num 32.8 #>  $ Oceania.Melanesia.Fiji                             : num 24.4 #>  $ Oceania.Melanesia.New Caledonia                    : num 4.03 #>  $ Oceania.Melanesia.Papua New Guinea                 : num 50.3 #>   [list output truncated]"},{"path":"/index.html","id":"id_-how--melt","dir":"","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"• how = \"melt\"","title":"Revisiting Base Rapply","text":", use = \"melt\" return melted data.frame pruned list similar format reshape2::melt() applied nested list. melted data.frame can used reconstruct nested list = \"unmelt\",","code":"## drop all logical NA's and return melted data.frame oceania_melt <- rrapply(   renewable_oceania,   f = \\(x) x,   classes = \"numeric\",   how = \"melt\" ) head(oceania_melt)  #>        L1                        L2               L3 value #> 1 Oceania Australia and New Zealand        Australia  9.32 #> 2 Oceania Australia and New Zealand      New Zealand 32.76 #> 3 Oceania                 Melanesia             Fiji 24.36 #> 4 Oceania                 Melanesia    New Caledonia  4.03 #> 5 Oceania                 Melanesia Papua New Guinea 50.34 #> 6 Oceania                 Melanesia  Solomon Islands 65.73 ## reconstruct nested list from melted data.frame rrapply(oceania_melt, how = \"unmelt\") |>   str(list.len = 3, give.attr = FALSE)  #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/index.html","id":"id_-how--bind","dir":"","previous_headings":"When to use rrapply() > List pruning and unnesting","what":"• how = \"bind\"","title":"Revisiting Base Rapply","text":"Nested lists containing repeated observations can unnested = \"bind\", returns wide data.frame similar format dplyr::bind_rows() applied list data.frames repeated application tidyr::unnest_wider() nested data.frame. Hint: set options = list(namecols = TRUE) include parent list names associated row wide data.frame individual columns L1, L2, etc.","code":"## data: nested list of Pokemon properties in Pokemon GO data(\"pokedex\") str(pokedex, list.len = 3)  #> List of 1 #>  $ pokemon:List of 151 #>   ..$ :List of 16 #>   .. ..$ id            : int 1 #>   .. ..$ num           : chr \"001\" #>   .. ..$ name          : chr \"Bulbasaur\" #>   .. .. [list output truncated] #>   ..$ :List of 17 #>   .. ..$ id            : int 2 #>   .. ..$ num           : chr \"002\" #>   .. ..$ name          : chr \"Ivysaur\" #>   .. .. [list output truncated] #>   ..$ :List of 15 #>   .. ..$ id            : int 3 #>   .. ..$ num           : chr \"003\" #>   .. ..$ name          : chr \"Venusaur\" #>   .. .. [list output truncated] #>   .. [list output truncated] ## unnest list to wide data.frame rrapply(pokedex, how = \"bind\")[, c(1:3, 5:8)] |>   head(n = 9)  #>   id num       name          type height   weight            candy #> 1  1 001  Bulbasaur Grass, Poison 0.71 m   6.9 kg  Bulbasaur Candy #> 2  2 002    Ivysaur Grass, Poison 0.99 m  13.0 kg  Bulbasaur Candy #> 3  3 003   Venusaur Grass, Poison 2.01 m 100.0 kg  Bulbasaur Candy #> 4  4 004 Charmander          Fire 0.61 m   8.5 kg Charmander Candy #> 5  5 005 Charmeleon          Fire 1.09 m  19.0 kg Charmander Candy #> 6  6 006  Charizard  Fire, Flying 1.70 m  90.5 kg Charmander Candy #> 7  7 007   Squirtle         Water 0.51 m   9.0 kg   Squirtle Candy #> 8  8 008  Wartortle         Water 0.99 m  22.5 kg   Squirtle Candy #> 9  9 009  Blastoise         Water 1.60 m  85.5 kg   Squirtle Candy ## bind to data.frame including parent columns rrapply(pokedex, how = \"bind\", options = list(namecols = TRUE))[, c(1:5, 7:10)] |>   head(n = 6)  #>        L1 L2 id num       name          type height   weight            candy #> 1 pokemon  1  1 001  Bulbasaur Grass, Poison 0.71 m   6.9 kg  Bulbasaur Candy #> 2 pokemon  2  2 002    Ivysaur Grass, Poison 0.99 m  13.0 kg  Bulbasaur Candy #> 3 pokemon  3  3 003   Venusaur Grass, Poison 2.01 m 100.0 kg  Bulbasaur Candy #> 4 pokemon  4  4 004 Charmander          Fire 0.61 m   8.5 kg Charmander Candy #> 5 pokemon  5  5 005 Charmeleon          Fire 1.09 m  19.0 kg Charmander Candy #> 6 pokemon  6  6 006  Charizard  Fire, Flying 1.70 m  90.5 kg Charmander Candy"},{"path":"/index.html","id":"condition-function","dir":"","previous_headings":"When to use rrapply()","what":"Condition function","title":"Revisiting Base Rapply","text":"Base rapply() allows apply function f list elements certain types classes via classes argument. rrapply() generalizes option via additional condition argument, accepts function use condition predicate apply f subset list elements.","code":"## drop all NA elements using condition  rrapply(   renewable_oceania,   condition = \\(x) !is.na(x),   f = \\(x) x,   how = \"prune\" ) |>   str(list.len = 3, give.attr = FALSE)  #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated] ## filter all countries with values > 85% rrapply(   renewable_energy_by_country,   condition = \\(x) x > 85,   how = \"prune\" ) |>   str(give.attr = FALSE)  #> List of 1 #>  $ World:List of 1 #>   ..$ Africa:List of 1 #>   .. ..$ Sub-Saharan Africa:List of 3 #>   .. .. ..$ Eastern Africa:List of 7 #>   .. .. .. ..$ Burundi                    : num 89.2 #>   .. .. .. ..$ Ethiopia                   : num 91.9 #>   .. .. .. ..$ Rwanda                     : num 86 #>   .. .. .. ..$ Somalia                    : num 94.7 #>   .. .. .. ..$ Uganda                     : num 88.6 #>   .. .. .. ..$ United Republic of Tanzania: num 86.1 #>   .. .. .. ..$ Zambia                     : num 88.5 #>   .. .. ..$ Middle Africa :List of 2 #>   .. .. .. ..$ Chad                            : num 85.3 #>   .. .. .. ..$ Democratic Republic of the Congo: num 97 #>   .. .. ..$ Western Africa:List of 1 #>   .. .. .. ..$ Guinea-Bissau: num 86.5"},{"path":"/index.html","id":"special-arguments-xname-xpos-xparents-and-xsiblings","dir":"","previous_headings":"When to use rrapply()","what":"Special arguments .xname, .xpos, .xparents and .xsiblings","title":"Revisiting Base Rapply","text":"base rapply(), f function access content list element evaluation, convenient way access name location nested list inside f. rrapply() defines special arguments .xname, .xpos, .xparents, .xsiblings inside f condition functions (addition principal function argument): .xname evaluates name list element; .xpos evaluates position element nested list structured integer vector; .xparents evaluates vector parent list names path current list element; .xsiblings evaluates parent list containing current list element direct siblings.","code":"## apply f based on element's name rrapply(   renewable_oceania,   condition = \\(x) !is.na(x),   f = \\(x, .xname) sprintf(\"Renewable energy in %s: %.2f%%\", .xname, x),   how = \"flatten\" ) |>   head(n = 5)  #>                                      Australia  #>         \"Renewable energy in Australia: 9.32%\"  #>                                    New Zealand  #>      \"Renewable energy in New Zealand: 32.76%\"  #>                                           Fiji  #>             \"Renewable energy in Fiji: 24.36%\"  #>                                  New Caledonia  #>     \"Renewable energy in New Caledonia: 4.03%\"  #>                               Papua New Guinea  #> \"Renewable energy in Papua New Guinea: 50.34%\"  ## filter elements by name  rrapply(   renewable_energy_by_country,   condition = \\(x, .xname) .xname %in% c(\"Belgium\", \"Netherlands\", \"Luxembourg\"),   how = \"prune\" ) |>   str(give.attr = FALSE)  #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 1 #>   .. ..$ Western Europe:List of 3 #>   .. .. ..$ Belgium    : num 9.14 #>   .. .. ..$ Luxembourg : num 13.5 #>   .. .. ..$ Netherlands: num 5.78  ## filter European countries > 50% using .xpos rrapply(   renewable_energy_by_country,   condition = \\(x, .xpos) identical(.xpos[1:2], c(1L, 5L)) && x > 50,   how = \"prune\" ) |>   str(give.attr = FALSE)  #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 2 #>   .. ..$ Northern Europe:List of 3 #>   .. .. ..$ Iceland: num 78.1 #>   .. .. ..$ Norway : num 59.5 #>   .. .. ..$ Sweden : num 51.4 #>   .. ..$ Western Europe :List of 1 #>   .. .. ..$ Liechtenstein: num 62.9  ## filter European countries > 50% using .xparents rrapply(   renewable_energy_by_country,    condition = \\(x, .xparents) \"Europe\" %in% .xparents && x > 50,   how = \"prune\" ) |>   str(give.attr = FALSE)  #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 2 #>   .. ..$ Northern Europe:List of 3 #>   .. .. ..$ Iceland: num 78.1 #>   .. .. ..$ Norway : num 59.5 #>   .. .. ..$ Sweden : num 51.4 #>   .. ..$ Western Europe :List of 1 #>   .. .. ..$ Liechtenstein: num 62.9  ## return position of element in list rrapply(   renewable_energy_by_country,   condition = \\(x, .xname) .xname == \"Sweden\",   f = \\(x, .xpos) .xpos,   how = \"flatten\" )  #> $Sweden #> [1]  1  5  2 14  ## return siblings of element in list rrapply(   renewable_energy_by_country,   condition = \\(x, .xsiblings) \"Sweden\" %in% names(.xsiblings),   how = \"flatten\" ) |>   head(n = 5)  #> Aland Islands       Denmark       Estonia Faroe Islands       Finland  #>            NA         33.06         26.55          4.24         42.03  ## filter elements and unnest list   rrapply(   pokedex,   condition = \\(x, .xpos, .xname) length(.xpos) < 4 & .xname %in% c(\"num\", \"name\", \"type\"),   how = \"bind\" ) |>   head()  #>   num       name          type #> 1 001  Bulbasaur Grass, Poison #> 2 002    Ivysaur Grass, Poison #> 3 003   Venusaur Grass, Poison #> 4 004 Charmander          Fire #> 5 005 Charmeleon          Fire #> 6 006  Charizard  Fire, Flying"},{"path":"/index.html","id":"modifying-list-elements","dir":"","previous_headings":"When to use rrapply()","what":"Modifying list elements","title":"Revisiting Base Rapply","text":"default, base rapply() rrapply() recurse “list-like” element. Set classes = \"list\" rrapply() override apply f list element (.e. sublist) satisfies condition argument. can useful e.g. collapse sublists calculate summary statistics across elements nested list: Hint: data.frames also list-like objects, rrapply() applies f individual data.frame columns default. Set classes = \"data.frame\" avoid behavior apply f condition functions complete data.frame objects instead individual data.frame columns.","code":"## calculate mean value of Europe rrapply(   renewable_energy_by_country,     condition = \\(x, .xname) .xname == \"Europe\",   f = \\(x) mean(unlist(x), na.rm = TRUE),   classes = \"list\",   how = \"flatten\" )  #>   Europe  #> 22.36565  ## calculate mean value for each continent ## (Antartica's value is missing) rrapply(   renewable_energy_by_country,    condition = \\(x, .xpos) length(.xpos) == 2,   f = \\(x) mean(unlist(x), na.rm = TRUE),   classes = \"list\" ) |>   str(give.attr = FALSE)  #> List of 1 #>  $ World:List of 6 #>   ..$ Africa    : num 54.3 #>   ..$ Americas  : num 18.2 #>   ..$ Antarctica: logi NA #>   ..$ Asia      : num 17.9 #>   ..$ Europe    : num 22.4 #>   ..$ Oceania   : num 17.8  ## simplify pokemon evolutions to character vectors  rrapply(   pokedex,   condition = \\(x, .xname) .xname %in% c(\"name\", \"next_evolution\", \"prev_evolution\"),    f = \\(x) if(is.list(x)) sapply(x, `[[`, \"name\") else x,   classes = c(\"character\", \"list\"),   how = \"bind\" ) |>   head(n = 9)  #>         name        next_evolution         prev_evolution #> 1  Bulbasaur     Ivysaur, Venusaur                     NA #> 2    Ivysaur              Venusaur              Bulbasaur #> 3   Venusaur                    NA     Bulbasaur, Ivysaur #> 4 Charmander Charmeleon, Charizard                     NA #> 5 Charmeleon             Charizard             Charmander #> 6  Charizard                    NA Charmander, Charmeleon #> 7   Squirtle  Wartortle, Blastoise                     NA #> 8  Wartortle             Blastoise               Squirtle #> 9  Blastoise                    NA    Squirtle, Wartortle"},{"path":[]},{"path":"/index.html","id":"id_-how--recurse","dir":"","previous_headings":"When to use rrapply() > Recursive list updating","what":"• how = \"recurse\"","title":"Revisiting Base Rapply","text":"classes = \"list\" = \"recurse\", rrapply() applies f function list element satisfies condition argument similar previous section, recurses updated list-like element application f. can useful e.g. recursively update class attributes elements nested list:","code":"## recursively remove all list attributes rrapply(   renewable_oceania,   f = \\(x) c(x),   classes = c(\"list\", \"ANY\"),   how = \"recurse\" ) |>   str(list.len = 3, give.attr = TRUE)  #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : logi NA #>   .. ..$ Cocos (Keeling) Islands          : logi NA #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/index.html","id":"id_-how--names","dir":"","previous_headings":"When to use rrapply() > Recursive list updating","what":"• how = \"names\"","title":"Revisiting Base Rapply","text":"option = \"names\" special case = \"recurse\", value f used replace name evaluated list element instead content (options). default, = \"names\" uses classes = c(\"list\", \"\") order allow updating names nested list.","code":"## recursively replace all names by M49-codes rrapply(   renewable_oceania,   f = \\(x) attr(x, \"M49-code\"),   how = \"names\" ) |>   str(list.len = 3, give.attr = FALSE)  #> List of 1 #>  $ 009:List of 4 #>   ..$ 053:List of 6 #>   .. ..$ 036: num 9.32 #>   .. ..$ 162: logi NA #>   .. ..$ 166: logi NA #>   .. .. [list output truncated] #>   ..$ 054:List of 5 #>   .. ..$ 242: num 24.4 #>   .. ..$ 540: num 4.03 #>   .. ..$ 598: num 50.3 #>   .. .. [list output truncated] #>   ..$ 057:List of 8 #>   .. ..$ 316: num 3.03 #>   .. ..$ 296: num 45.4 #>   .. ..$ 584: num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]"},{"path":"/index.html","id":"expression-objects","dir":"","previous_headings":"When to use rrapply()","what":"Expression objects","title":"Revisiting Base Rapply","text":"Base rapply() include recursion expression objects. contrast rrapply() supports recursion call objects expression vectors, treated nested lists based abstract syntax trees. , functionality applies nested lists extends directly call objects expression vectors. update abstract syntax tree call object, use = \"replace\": update abstract syntax tree return nested list, use = \"list\": modes = \"prune\", = \"flatten\" = \"melt\" return pruned abstract syntax tree : nested list, flattened list melted data.frame respectively. identical application rrapply() abstract syntax tree formatted nested list. illustrate, return names (.e. symbols) abstract syntax tree part base R: details examples use rrapply() function see accompanying package vignette vignettes folder Articles section https://jorischau.github.io/rrapply/.","code":"## language object (lang <- quote(y <- x <- 1 + TRUE))  #> y <- x <- 1 + TRUE  ## replace logicals by integers  rrapply(lang, classes = \"logical\", f = as.numeric, how = \"replace\")  #> y <- x <- 1 + 1 ## update and decompose call object rrapply(lang, f = function(x) ifelse(is.logical(x), as.numeric(x), x), how = \"list\") |>   str()  #> List of 3 #>  $ : symbol <- #>  $ : symbol y #>  $ :List of 3 #>   ..$ : symbol <- #>   ..$ : symbol x #>   ..$ :List of 3 #>   .. ..$ : symbol + #>   .. ..$ : num 1 #>   .. ..$ : num 1 ## expression vector expr <- expression(y <- x <- 1, f(g(2 * pi))) is_new_name <- function(x) !exists(as.character(x), envir = baseenv())  ## prune and decompose expression rrapply(expr, classes = \"name\", condition = is_new_name, how = \"prune\") |>   str()  #> List of 2 #>  $ :List of 2 #>   ..$ : symbol y #>   ..$ :List of 1 #>   .. ..$ : symbol x #>  $ :List of 2 #>   ..$ : symbol f #>   ..$ :List of 1 #>   .. ..$ : symbol g  ## prune and flatten expression rrapply(expr, classes = \"name\", condition = is_new_name, how = \"flatten\") |>   str()  #> List of 4 #>  $ : symbol y #>  $ : symbol x #>  $ : symbol f #>  $ : symbol g  ## prune and melt expression rrapply(expr, classes = \"name\", condition = is_new_name, f = as.character, how = \"melt\")  #>   L1 L2   L3 value #> 1  1  2 <NA>     y #> 2  1  3    2     x #> 3  2  1 <NA>     f #> 4  2  2    1     g"},{"path":"/reference/pokedex.html","id":null,"dir":"Reference","previous_headings":"","what":"Pokedex of Pokemon GO — pokedex","title":"Pokedex of Pokemon GO — pokedex","text":"nested list containing property values original 151 Pokemon present Pokemon GO. data available JSON format GitHub (credits Gianluca Bonifazi).","code":""},{"path":"/reference/pokedex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pokedex of Pokemon GO — pokedex","text":"","code":"pokedex"},{"path":"/reference/pokedex.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Pokedex of Pokemon GO — pokedex","text":"nested list containing 151 sublists 17 list elements: id integer, Identification number num character, Pokemon number official Pokedex name character, Pokemon name img character, URL png image Pokemon type character, Pokemon type height character, Pokemon height weight character, Pokemon weight candy character, type candy used evolve Pokemon given transfered candy_count integer, amount candies required evolve egg character, travel distance hatch egg spawn_change numeric, spawn change percentage avg_spawns integer, number spawns per 10.000 spawns spawn_time character, local time spawns active multipliers numeric, multiplier Combat Power (CP) evolution weakness character, types Pokemon Pokemon weak next_evolution list, numbers (num) names (name) successive evolutions prev_evolution list, numbers (num) names (name) previous evolutions","code":""},{"path":"/reference/pokedex.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Pokedex of Pokemon GO — pokedex","text":"PokemonGO-Pokedex","code":""},{"path":"/reference/renewable_energy_by_country.html","id":null,"dir":"Reference","previous_headings":"","what":"UNSD renewable energy share by country in 2016 — renewable_energy_by_country","title":"UNSD renewable energy share by country in 2016 — renewable_energy_by_country","text":"nested list containing renewable energy shares percentage total energy consumption per country 2016. dataset publicly available United Nations Open SDG Data Hub.","code":""},{"path":"/reference/renewable_energy_by_country.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UNSD renewable energy share by country in 2016 — renewable_energy_by_country","text":"","code":"renewable_energy_by_country"},{"path":"/reference/renewable_energy_by_country.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"UNSD renewable energy share by country in 2016 — renewable_energy_by_country","text":"249 countries areas structured nested list based geographical location  according United Nations M49 Standard (UNSD-M49).  numeric values listed country area percentages, data available value NA. list element contains \"M49-code\" attribute UN Standard Country Area Codes Statistical Use (Series M, . 49).","code":""},{"path":"/reference/renewable_energy_by_country.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"UNSD renewable energy share by country in 2016 — renewable_energy_by_country","text":"UNSD_SDG07","code":""},{"path":"/reference/rrapply.html","id":null,"dir":"Reference","previous_headings":"","what":"Reimplementation of base-R's rapply — rrapply","title":"Reimplementation of base-R's rapply — rrapply","text":"rrapply reimplemented extended version rapply recursively apply function f  set elements list deciding result structured.","code":""},{"path":"/reference/rrapply.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reimplementation of base-R's rapply — rrapply","text":"","code":"rrapply(   object,   condition,   f,   classes = \"ANY\",   deflt = NULL,   how = c(\"replace\", \"list\", \"unlist\", \"prune\", \"flatten\", \"melt\", \"bind\", \"recurse\",     \"unmelt\", \"names\"),   options,   ... )"},{"path":"/reference/rrapply.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reimplementation of base-R's rapply — rrapply","text":"object list, expression vector, call object, .e., “list-like”. condition condition function one “principal” argument optional special arguments .xname, .xpos,  .xparents /.xsiblings (see ‘Details’), passing arguments via .... f function one “principal” argument optional special arguments .xname, .xpos, .xparents  /.xsiblings (see ‘Details’), passing arguments via .... classes character vector class names, \"\" match class terminal node. Include \"list\" \"data.frame\" match class non-terminal nodes well. deflt default result (used = \"list\" = \"unlist\"). character string partially matching ten possibilities given: see ‘Details’. options named list additional options namesep, simplify, namecols /coldepth  apply certain choices : see ‘Details’. ... additional arguments passed call f condition.","code":""},{"path":"/reference/rrapply.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reimplementation of base-R's rapply — rrapply","text":"= \"unlist\", vector rapply. = \"list\", = \"replace\", = \"recurse\" = \"names\",  “list-like” similar structure object rapply. = \"prune\", pruned “list-like” object  similar structure object pruned list elements based classes condition. = \"flatten\", flattened pruned vector list pruned elements based classes condition. = \"melt\", melted data.frame containing node paths  values pruned list elements based classes condition. = \"bind\", wide data.frame repeated list elements expanded single data.frame rows aligned identical list names using coercion rules = \"unlist\". repeated list elements  subject pruning based classes condition. = \"unmelt\", nested list list names values defined  data.frame object.","code":""},{"path":"/reference/rrapply.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Reimplementation of base-R's rapply — rrapply","text":"rrapply allows f function argument missing, case function applied list  elements. = \"unmelt\" requires input data.frame returned = \"melt\" character columns name nested list components final list- vector-column containing values nested list elements.","code":""},{"path":"/reference/rrapply.html","id":"how-to-structure-result","dir":"Reference","previous_headings":"","what":"How to structure result","title":"Reimplementation of base-R's rapply — rrapply","text":"addition rapply's modes set equal \"replace\", \"list\" \"unlist\",  seven choices \"prune\", \"flatten\", \"melt\", \"bind\", \"unmelt\", \"recurse\"  \"names\" available: = \"prune\" filters list elements subject application f list object. original  list structure retained, similar non-pruned options = \"replace\" = \"list\". = \"flatten\" efficient way return flattened unnested version pruned list. default = \"flatten\"  uses similar coercion rules = \"unlist\", can disabled simplify = FALSE options argument. = \"melt\" returns melted data.frame pruned list, row contains path single  terminal node pruned list depth layers L1, L2, . column \"value\" contains  possibly coerced values terminal nodes equivalent result = \"flatten\". list names present,  node names data.frame default indices list elements \"1\", \"2\", etc. = \"bind\" used unnest nested list containing repeated sublists wide data.frame. repeated sublist expanded  single row data.frame identical sublist component names aligned individual columns. default, list layer  containing repeated sublists identified based minimal depth detected across leaf nodes, can set manually coldepth  options argument. = \"unmelt\" special case reconstructs nested list melted data.frame. reason, = \"unmelt\"  applies data.frames format returned = \"melt\". Internally, = \"unmelt\" first reconstructs  nested list melted data.frame second uses functional framework = \"replace\". = \"recurse\" specialized option useful combination e.g. classes = \"list\" recurse  updated “list-like” elements. explained detail . = \"names\" modifies names nested list elements instead list content. = \"names\" internally works   similar = \"list\", except value f used replace name list element evaluation  instead content.","code":""},{"path":"/reference/rrapply.html","id":"condition-function","dir":"Reference","previous_headings":"","what":"Condition function","title":"Reimplementation of base-R's rapply — rrapply","text":"rapply rrapply allow apply f list elements certain classes via classes argument.  rrapply generalizes concept via additional condition argument, accepts function use condition  predicate select list elements f applied. Conceptually, f function applied list elements  condition function exactly evaluates TRUE similar isTRUE. condition function missing,  f applied list elements. Since condition function generalizes classes argument, allowed use deflt argument  together = \"list\" = \"unlist\" set default value list elements condition  evaluate TRUE.","code":""},{"path":"/reference/rrapply.html","id":"correct-use-of-","dir":"Reference","previous_headings":"","what":"Correct use of ...","title":"Reimplementation of base-R's rapply — rrapply","text":"principal argument f condition functions evaluates content list element. arguments  f condition (besides special arguments .xname, .xpos, etc. discussed ) supplied via dots ...  argument need defined function arguments f condition function (existing), even  used function . See also ‘Examples’ section.","code":""},{"path":"/reference/rrapply.html","id":"special-arguments-xname-xpos-xparents-and-xsiblings","dir":"Reference","previous_headings":"","what":"Special arguments .xname, .xpos, .xparents and .xsiblings","title":"Reimplementation of base-R's rapply — rrapply","text":"f condition functions accept four special arguments .xname, .xpos, .xparents .xsiblings addition first principal argument. .xname argument evaluates name list element. .xpos argument evaluates  position element nested list structured integer vector. , x = list(list(\"y\", \"z\")), .xpos  location c(1, 2) corresponds list element x[[c(1, 2)]]. .xparents argument evaluates vector parent  node names path list element. .xsiblings argument evaluates complete (sub)list includes list element direct child. names .xname, .xpos, .xparents .xsiblings need explicitly included function arguments f  condition (addition principal argument). See also ‘Examples’ section.","code":""},{"path":"/reference/rrapply.html","id":"avoid-recursing-into-list-nodes","dir":"Reference","previous_headings":"","what":"Avoid recursing into list nodes","title":"Reimplementation of base-R's rapply — rrapply","text":"default, rrapply recurses “list-like” element. classes = \"list\", behavior overridden  f function also applied list element object satisfies condition. expression objects, use  classes = \"language\", classes = \"expression\" classes = \"pairlist\" avoid recursing branches abstract  syntax tree object. condition classes arguments satisfied “list-like” element,  rrapply recurse sublist, apply f function nodes satisfy condition classes,  . Note behavior can triggered using classes argument condition argument.","code":""},{"path":"/reference/rrapply.html","id":"recursive-list-node-updating","dir":"Reference","previous_headings":"","what":"Recursive list node updating","title":"Reimplementation of base-R's rapply — rrapply","text":"classes = \"list\" = \"recurse\", rrapply applies f function list element object satisfies  condition similar previous section using = \"replace\", recurses updated list-like element  application f function. primary use = \"recurse\" combination classes = \"list\"  recursively update instance class attributes nodes nested list.","code":""},{"path":"/reference/rrapply.html","id":"avoid-recursing-into-data-frames","dir":"Reference","previous_headings":"","what":"Avoid recursing into data.frames","title":"Reimplementation of base-R's rapply — rrapply","text":"classes = \"\" (default), rrapply recurses “list-like” objects equivalent rapply.  Since data.frames “list-like” objects, f function descend individual columns data.frame.  avoid behavior, set classes = \"data.frame\", case f condition functions applied directly  data.frame columns. Note behavior can triggered using classes argument condition argument.","code":""},{"path":"/reference/rrapply.html","id":"list-attributes","dir":"Reference","previous_headings":"","what":"List attributes","title":"Reimplementation of base-R's rapply — rrapply","text":"rapply intermediate list attributes (located terminal nodes) kept = \"replace\", dropped  = \"list\". avoid unexpected behavior, rrapply always preserves intermediate list attributes using = \"replace\",  = \"list\", = \"prune\" = \"names\". = \"unlist\", = \"flatten\", = \"melt\" = \"bind\"  intermediate list attributes preserved result longer nested list.","code":""},{"path":"/reference/rrapply.html","id":"expressions","dir":"Reference","previous_headings":"","what":"Expressions","title":"Reimplementation of base-R's rapply — rrapply","text":"Call objects expression vectors also accepted object argument, treated nested lists based internal abstract syntax trees. , functionality applies nested lists extends directly call objects expression vectors. object  call object expression vector, = \"replace\" always maintains type object, whereas = \"list\" returns result  structured nested list. = \"prune\", = \"flatten\" = \"melt\" return pruned abstract syntax tree : nested list,  flattened list melted data.frame respectively. identical application rrapply abstract syntax tree formatted nested list.","code":""},{"path":"/reference/rrapply.html","id":"additional-options","dir":"Reference","previous_headings":"","what":"Additional options","title":"Reimplementation of base-R's rapply — rrapply","text":"options argument accepts named list configure several default options apply certain choices . options  list can contain () named components namesep, simplify, namecols /coldepth: namesep, character separator used combine parent child list names = \"flatten\" = \"bind\". namesep = NA (default),  parent names included = \"flatten\" default separator \".\" used = \"bind\". Note namesep used  = \"unlist\" name separator always defaults \".\". simplify, logical value indicating whether flattened unnested list = \"flatten\" = \"melt\" simplified  according standard coercion rules similar = \"unlist\". default simplify = TRUE. simplify = FALSE,  object flattened single-layer list returned . namecols, logical value applies = \"bind\" indicating whether parent node names associated expanded sublist  included columns L1, L2, etc. wide data.frame returned = \"bind\". coldepth, integer value indicating depth (starting depth 1) list elements mapped individual columns  wide data.frame returned = \"bind\". coldepth = 0 (default), depth layer identified automatically based  minimal depth detected across leaf nodes. option applies = \"bind\".","code":""},{"path":[]},{"path":"/reference/rrapply.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reimplementation of base-R's rapply — rrapply","text":"","code":"# Example data  ## Renewable energy shares per country (% of total consumption) in 2016 data(\"renewable_energy_by_country\")  ## Renewable energy shares in Oceania renewable_oceania <- renewable_energy_by_country[[\"World\"]][\"Oceania\"]  ## Pokemon properties in Pokemon GO data(\"pokedex\")  # List pruning and unnesting  ## Drop logical NA's while preserving list structure  na_drop_oceania <- rrapply(   renewable_oceania,   f = function(x) x,   classes = \"numeric\",   how = \"prune\" ) str(na_drop_oceania, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]  ## Drop logical NA's and return unnested list na_drop_oceania2 <- rrapply(   renewable_oceania,   classes = \"numeric\",   how = \"flatten\" ) head(na_drop_oceania2, n = 10) #>        Australia      New Zealand             Fiji    New Caledonia  #>             9.32            32.76            24.36             4.03  #> Papua New Guinea  Solomon Islands          Vanuatu             Guam  #>            50.34            65.73            33.67             3.03  #>         Kiribati Marshall Islands  #>            45.43            11.75   ## Flatten to simple list with full names na_drop_oceania3 <- rrapply(   renewable_oceania,   classes = \"numeric\",   how = \"flatten\",   options = list(namesep = \".\", simplify = FALSE) )  str(na_drop_oceania3, list.len = 10, give.attr = FALSE) #> List of 22 #>  $ Oceania.Australia and New Zealand.Australia        : num 9.32 #>  $ Oceania.Australia and New Zealand.New Zealand      : num 32.8 #>  $ Oceania.Melanesia.Fiji                             : num 24.4 #>  $ Oceania.Melanesia.New Caledonia                    : num 4.03 #>  $ Oceania.Melanesia.Papua New Guinea                 : num 50.3 #>  $ Oceania.Melanesia.Solomon Islands                  : num 65.7 #>  $ Oceania.Melanesia.Vanuatu                          : num 33.7 #>  $ Oceania.Micronesia.Guam                            : num 3.03 #>  $ Oceania.Micronesia.Kiribati                        : num 45.4 #>  $ Oceania.Micronesia.Marshall Islands                : num 11.8 #>   [list output truncated]  ## Drop logical NA's and return melted data.frame na_drop_oceania4 <- rrapply(   renewable_oceania,   classes = \"numeric\",   how = \"melt\" ) head(na_drop_oceania4) #>        L1                        L2               L3 value #> 1 Oceania Australia and New Zealand        Australia  9.32 #> 2 Oceania Australia and New Zealand      New Zealand 32.76 #> 3 Oceania                 Melanesia             Fiji 24.36 #> 4 Oceania                 Melanesia    New Caledonia  4.03 #> 5 Oceania                 Melanesia Papua New Guinea 50.34 #> 6 Oceania                 Melanesia  Solomon Islands 65.73  ## Reconstruct nested list from melted data.frame na_drop_oceania5 <- rrapply(   na_drop_oceania4,   how = \"unmelt\" ) str(na_drop_oceania5, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]  ## Unnest list to wide data.frame pokedex_wide <- rrapply(pokedex, how = \"bind\") head(pokedex_wide) #>   id num       name                                              img #> 1  1 001  Bulbasaur http://www.serebii.net/pokemongo/pokemon/001.png #> 2  2 002    Ivysaur http://www.serebii.net/pokemongo/pokemon/002.png #> 3  3 003   Venusaur http://www.serebii.net/pokemongo/pokemon/003.png #> 4  4 004 Charmander http://www.serebii.net/pokemongo/pokemon/004.png #> 5  5 005 Charmeleon http://www.serebii.net/pokemongo/pokemon/005.png #> 6  6 006  Charizard http://www.serebii.net/pokemongo/pokemon/006.png #>            type height   weight            candy candy_count         egg #> 1 Grass, Poison 0.71 m   6.9 kg  Bulbasaur Candy          25        2 km #> 2 Grass, Poison 0.99 m  13.0 kg  Bulbasaur Candy         100 Not in Eggs #> 3 Grass, Poison 2.01 m 100.0 kg  Bulbasaur Candy          NA Not in Eggs #> 4          Fire 0.61 m   8.5 kg Charmander Candy          25        2 km #> 5          Fire 1.09 m  19.0 kg Charmander Candy         100 Not in Eggs #> 6  Fire, Flying 1.70 m  90.5 kg Charmander Candy          NA Not in Eggs #>   spawn_chance avg_spawns spawn_time multipliers                 weaknesses #> 1       0.6900      69.00      20:00        1.58 Fire, Ice, Flying, Psychic #> 2       0.0420       4.20      07:00    1.2, 1.6 Fire, Ice, Flying, Psychic #> 3       0.0170       1.70      11:30          NA Fire, Ice, Flying, Psychic #> 4       0.2530      25.30      08:45        1.65        Water, Ground, Rock #> 5       0.0120       1.20      19:00        1.79        Water, Ground, Rock #> 6       0.0031       0.31      13:34          NA      Water, Electric, Rock #>   next_evolution.1.num next_evolution.1.name next_evolution.2.num #> 1                  002               Ivysaur                  003 #> 2                  003              Venusaur                 <NA> #> 3                 <NA>                  <NA>                 <NA> #> 4                  005            Charmeleon                  006 #> 5                  006             Charizard                 <NA> #> 6                 <NA>                  <NA>                 <NA> #>   next_evolution.2.name prev_evolution.1.num prev_evolution.1.name #> 1              Venusaur                 <NA>                  <NA> #> 2                  <NA>                  001             Bulbasaur #> 3                  <NA>                  001             Bulbasaur #> 4             Charizard                 <NA>                  <NA> #> 5                  <NA>                  004            Charmander #> 6                  <NA>                  004            Charmander #>   prev_evolution.2.num prev_evolution.2.name next_evolution.3.num #> 1                 <NA>                  <NA>                 <NA> #> 2                 <NA>                  <NA>                 <NA> #> 3                  002               Ivysaur                 <NA> #> 4                 <NA>                  <NA>                 <NA> #> 5                 <NA>                  <NA>                 <NA> #> 6                  005            Charmeleon                 <NA> #>   next_evolution.3.name #> 1                  <NA> #> 2                  <NA> #> 3                  <NA> #> 4                  <NA> #> 5                  <NA> #> 6                  <NA>  ## Unnest to data.frame including parent columns pokemon_evolutions <- rrapply(   pokedex,    how = \"bind\",    options = list(namecols = TRUE, coldepth = 5) )  head(pokemon_evolutions, n = 10) #>         L1 L2             L3 L4 num       name #> 1  pokemon  1 next_evolution  1 002    Ivysaur #> 2  pokemon  1 next_evolution  2 003   Venusaur #> 3  pokemon  2 prev_evolution  1 001  Bulbasaur #> 4  pokemon  2 next_evolution  1 003   Venusaur #> 5  pokemon  3 prev_evolution  1 001  Bulbasaur #> 6  pokemon  3 prev_evolution  2 002    Ivysaur #> 7  pokemon  4 next_evolution  1 005 Charmeleon #> 8  pokemon  4 next_evolution  2 006  Charizard #> 9  pokemon  5 prev_evolution  1 004 Charmander #> 10 pokemon  5 next_evolution  1 006  Charizard  # Condition function  ## Drop all NA elements using condition function na_drop_oceania6 <- rrapply(   renewable_oceania,   condition = Negate(is.na),   how = \"prune\" ) str(na_drop_oceania6, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..$ Australia  : num 9.32 #>   .. ..$ New Zealand: num 32.8 #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 7 #>   .. ..$ Guam                            : num 3.03 #>   .. ..$ Kiribati                        : num 45.4 #>   .. ..$ Marshall Islands                : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]  ## Replace NA elements by a new value via the ... argument ## NB: the 'newvalue' argument should be present as function  ## argument in both 'f' and 'condition', even if unused. na_zero_oceania <- rrapply(   renewable_oceania,   condition = function(x, newvalue) is.na(x),   f = function(x, newvalue) newvalue,   newvalue = 0,   how = \"replace\" ) str(na_zero_oceania, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : num 0 #>   .. ..$ Cocos (Keeling) Islands          : num 0 #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]  ## Filter all countries with values above 85% renewable_energy_above_85 <- rrapply(   renewable_energy_by_country,   condition = function(x) x > 85,   how = \"prune\" ) str(renewable_energy_above_85, give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Africa:List of 1 #>   .. ..$ Sub-Saharan Africa:List of 3 #>   .. .. ..$ Eastern Africa:List of 7 #>   .. .. .. ..$ Burundi                    : num 89.2 #>   .. .. .. ..$ Ethiopia                   : num 91.9 #>   .. .. .. ..$ Rwanda                     : num 86 #>   .. .. .. ..$ Somalia                    : num 94.7 #>   .. .. .. ..$ Uganda                     : num 88.6 #>   .. .. .. ..$ United Republic of Tanzania: num 86.1 #>   .. .. .. ..$ Zambia                     : num 88.5 #>   .. .. ..$ Middle Africa :List of 2 #>   .. .. .. ..$ Chad                            : num 85.3 #>   .. .. .. ..$ Democratic Republic of the Congo: num 97 #>   .. .. ..$ Western Africa:List of 1 #>   .. .. .. ..$ Guinea-Bissau: num 86.5  # Special arguments .xname, .xpos, .xparents and .xsiblings  ## Apply a function using the name of the node renewable_oceania_text <- rrapply(   renewable_oceania,   condition = Negate(is.na),   f = function(x, .xname) sprintf(\"Renewable energy in %s: %.2f%%\", .xname, x),   how = \"flatten\" ) head(renewable_oceania_text, n = 10) #>                                      Australia  #>         \"Renewable energy in Australia: 9.32%\"  #>                                    New Zealand  #>      \"Renewable energy in New Zealand: 32.76%\"  #>                                           Fiji  #>             \"Renewable energy in Fiji: 24.36%\"  #>                                  New Caledonia  #>     \"Renewable energy in New Caledonia: 4.03%\"  #>                               Papua New Guinea  #> \"Renewable energy in Papua New Guinea: 50.34%\"  #>                                Solomon Islands  #>  \"Renewable energy in Solomon Islands: 65.73%\"  #>                                        Vanuatu  #>          \"Renewable energy in Vanuatu: 33.67%\"  #>                                           Guam  #>              \"Renewable energy in Guam: 3.03%\"  #>                                       Kiribati  #>         \"Renewable energy in Kiribati: 45.43%\"  #>                               Marshall Islands  #> \"Renewable energy in Marshall Islands: 11.75%\"   ## Extract values based on country names renewable_benelux <- rrapply(   renewable_energy_by_country,   condition = function(x, .xname) .xname %in% c(\"Belgium\", \"Netherlands\", \"Luxembourg\"),   how = \"prune\" ) str(renewable_benelux, give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 1 #>   .. ..$ Western Europe:List of 3 #>   .. .. ..$ Belgium    : num 9.14 #>   .. .. ..$ Luxembourg : num 13.5 #>   .. .. ..$ Netherlands: num 5.78  ## Filter European countries with value above 50% renewable_europe_above_50 <- rrapply(   renewable_energy_by_country,   condition = function(x, .xpos) identical(.xpos[c(1, 2)], c(1L, 5L)) & x > 50,   how = \"prune\" ) str(renewable_europe_above_50, give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 2 #>   .. ..$ Northern Europe:List of 3 #>   .. .. ..$ Iceland: num 78.1 #>   .. .. ..$ Norway : num 59.5 #>   .. .. ..$ Sweden : num 51.4 #>   .. ..$ Western Europe :List of 1 #>   .. .. ..$ Liechtenstein: num 62.9  ## Filter European countries with value above 50% renewable_europe_above_50 <- rrapply(   renewable_energy_by_country,   condition = function(x, .xparents) \"Europe\" %in% .xparents & x > 50,   how = \"prune\" ) str(renewable_europe_above_50, give.attr = FALSE) #> List of 1 #>  $ World:List of 1 #>   ..$ Europe:List of 2 #>   .. ..$ Northern Europe:List of 3 #>   .. .. ..$ Iceland: num 78.1 #>   .. .. ..$ Norway : num 59.5 #>   .. .. ..$ Sweden : num 51.4 #>   .. ..$ Western Europe :List of 1 #>   .. .. ..$ Liechtenstein: num 62.9  ## Return position of Sweden in list (xpos_sweden <- rrapply(   renewable_energy_by_country,   condition = function(x, .xname) identical(.xname, \"Sweden\"),   f = function(x, .xpos) .xpos,   how = \"flatten\" )) #> $Sweden #> [1]  1  5  2 14 #>  renewable_energy_by_country[[xpos_sweden$Sweden]] #> [1] 51.35 #> attr(,\"M49-code\") #> [1] \"752\"  ## Return neighbors of Sweden in list siblings_sweden <- rrapply(   renewable_energy_by_country,   condition = function(x, .xsiblings) \"Sweden\" %in% names(.xsiblings),   how = \"flatten\" ) head(siblings_sweden, n = 10) #> Aland Islands       Denmark       Estonia Faroe Islands       Finland  #>            NA         33.06         26.55          4.24         42.03  #>       Iceland       Ireland   Isle of Man        Latvia     Lithuania  #>         78.07          8.65          4.30         38.48         31.42   ## Unnest selected columns in Pokedex list  pokedex_small <- rrapply(    pokedex,    condition = function(x, .xpos, .xname) length(.xpos) < 4 & .xname %in% c(\"num\", \"name\", \"type\"),    how = \"bind\" )   head(pokedex_small) #>   num       name          type #> 1 001  Bulbasaur Grass, Poison #> 2 002    Ivysaur Grass, Poison #> 3 003   Venusaur Grass, Poison #> 4 004 Charmander          Fire #> 5 005 Charmeleon          Fire #> 6 006  Charizard  Fire, Flying  # Modifying list elements  ## Calculate mean value of Europe rrapply(   renewable_energy_by_country,     condition = function(x, .xname) .xname == \"Europe\",   f = function(x) mean(unlist(x), na.rm = TRUE),   classes = \"list\",   how = \"flatten\" ) #>   Europe  #> 22.36565   ## Calculate mean value for each continent ## (Antarctica's value is missing) renewable_continent_summary <- rrapply(   renewable_energy_by_country,     condition = function(x, .xpos) length(.xpos) == 2,   f = function(x) mean(unlist(x), na.rm = TRUE),   classes = \"list\" ) str(renewable_continent_summary, give.attr = FALSE) #> List of 1 #>  $ World:List of 6 #>   ..$ Africa    : num 54.3 #>   ..$ Americas  : num 18.2 #>   ..$ Antarctica: logi NA #>   ..$ Asia      : num 17.9 #>   ..$ Europe    : num 22.4 #>   ..$ Oceania   : num 17.8  ## Filter country or region by M49-code rrapply(   renewable_energy_by_country,   condition = function(x) attr(x, \"M49-code\") == \"155\",   f = function(x, .xname) .xname,   classes = c(\"list\", \"ANY\"),    how = \"unlist\" ) #> World.Europe.Western Europe  #>            \"Western Europe\"   # Recursive list updating  ## Recursively remove list attributes renewable_no_attrs <- rrapply(   renewable_oceania,   f = function(x) c(x),   classes = c(\"list\", \"ANY\"),   how = \"recurse\" )  str(renewable_no_attrs, list.len = 3, give.attr = TRUE) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..$ Australia                        : num 9.32 #>   .. ..$ Christmas Island                 : logi NA #>   .. ..$ Cocos (Keeling) Islands          : logi NA #>   .. .. [list output truncated] #>   ..$ Melanesia                :List of 5 #>   .. ..$ Fiji            : num 24.4 #>   .. ..$ New Caledonia   : num 4.03 #>   .. ..$ Papua New Guinea: num 50.3 #>   .. .. [list output truncated] #>   ..$ Micronesia               :List of 8 #>   .. ..$ Guam                                : num 3.03 #>   .. ..$ Kiribati                            : num 45.4 #>   .. ..$ Marshall Islands                    : num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]  ## recursively replace all names by M49-codes renewable_m49_names <- rrapply(   renewable_oceania,   f = function(x) attr(x, \"M49-code\"),   how = \"names\" )  str(renewable_m49_names, list.len = 3, give.attr = FALSE) #> List of 1 #>  $ 009:List of 4 #>   ..$ 053:List of 6 #>   .. ..$ 036: num 9.32 #>   .. ..$ 162: logi NA #>   .. ..$ 166: logi NA #>   .. .. [list output truncated] #>   ..$ 054:List of 5 #>   .. ..$ 242: num 24.4 #>   .. ..$ 540: num 4.03 #>   .. ..$ 598: num 50.3 #>   .. .. [list output truncated] #>   ..$ 057:List of 8 #>   .. ..$ 316: num 3.03 #>   .. ..$ 296: num 45.4 #>   .. ..$ 584: num 11.8 #>   .. .. [list output truncated] #>   .. [list output truncated]  # List attributes  ## how = \"list\" preserves all list attributes na_drop_oceania_attr <- rrapply(   renewable_oceania,   f = function(x) replace(x, is.na(x), 0),   how = \"list\" ) str(na_drop_oceania_attr, max.level = 2) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 6 #>   .. ..- attr(*, \"M49-code\")= chr \"053\" #>   ..$ Melanesia                :List of 5 #>   .. ..- attr(*, \"M49-code\")= chr \"054\" #>   ..$ Micronesia               :List of 8 #>   .. ..- attr(*, \"M49-code\")= chr \"057\" #>   ..$ Polynesia                :List of 10 #>   .. ..- attr(*, \"M49-code\")= chr \"061\" #>   ..- attr(*, \"M49-code\")= chr \"009\"  ## how = \"prune\" also preserves list attributes na_drop_oceania_attr2 <- rrapply(   renewable_oceania,   condition = Negate(is.na),   how = \"prune\" ) str(na_drop_oceania_attr2, max.level = 2) #> List of 1 #>  $ Oceania:List of 4 #>   ..$ Australia and New Zealand:List of 2 #>   .. ..- attr(*, \"M49-code\")= chr \"053\" #>   ..$ Melanesia                :List of 5 #>   .. ..- attr(*, \"M49-code\")= chr \"054\" #>   ..$ Micronesia               :List of 7 #>   .. ..- attr(*, \"M49-code\")= chr \"057\" #>   ..$ Polynesia                :List of 8 #>   .. ..- attr(*, \"M49-code\")= chr \"061\" #>   ..- attr(*, \"M49-code\")= chr \"009\"  # Expressions  ## Replace logicals by integers call_old <- quote(y <- x <- 1 + TRUE) call_new <- rrapply(call_old,    f = as.numeric,    how = \"replace\",   classes = \"logical\" ) str(call_new) #>  language y <- x <- 1 + 1  ## Update and decompose call object call_ast <- rrapply(call_old,    f = function(x) ifelse(is.logical(x), as.numeric(x), x),    how = \"list\" ) str(call_ast) #> List of 3 #>  $ : symbol <- #>  $ : symbol y #>  $ :List of 3 #>   ..$ : symbol <- #>   ..$ : symbol x #>   ..$ :List of 3 #>   .. ..$ : symbol + #>   .. ..$ : num 1 #>   .. ..$ : num 1  ## Prune and decompose expression expr <- expression(y <- x <- 1, f(g(2 * pi))) is_new_name <- function(x) !exists(as.character(x), envir = baseenv()) expr_prune <- rrapply(expr,    classes = \"name\",    condition = is_new_name,    how = \"prune\" ) str(expr_prune) #> List of 2 #>  $ :List of 2 #>   ..$ : symbol y #>   ..$ :List of 1 #>   .. ..$ : symbol x #>  $ :List of 2 #>   ..$ : symbol f #>   ..$ :List of 1 #>   .. ..$ : symbol g  ## Prune and flatten expression expr_flatten <- rrapply(expr,    classes = \"name\",    condition = is_new_name,    how = \"flatten\" ) str(expr_flatten) #> List of 4 #>  $ : symbol y #>  $ : symbol x #>  $ : symbol f #>  $ : symbol g  ## Prune and melt expression rrapply(expr,    classes = \"name\",    condition = is_new_name,    f = as.character,   how = \"melt\" ) #>   L1 L2   L3 value #> 1  1  2 <NA>     y #> 2  1  3    2     x #> 3  2  1 <NA>     f #> 4  2  2    1     g  ## Avoid recursing into call objects rrapply(   expr,    classes = \"language\",    condition = function(x) !any(sapply(x, is.call)),   how = \"flatten\" ) #> [[1]] #> x <- 1 #>  #> [[2]] #> 2 * pi #>"},{"path":"/news/index.html","id":"rrapply-125","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.5","title":"rrapply 1.2.5","text":"CRAN release: 2022-07-21 Breaking change: data.frame columns = \"bind\" include child list names instead full path names Added new option = \"names\" recursively update list names namesep, separator combine list names = \"flatten\" = \"bind\"; simplify, coerce flattened list vector = \"flatten\" = \"melt\"; namecols, include parent names columns L1, L2, … wide data.frame = \"bind\"; coldepth, override depth layer mapping list elements data.frame columns = \"bind\"","code":""},{"path":"/news/index.html","id":"rrapply-124","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.4","title":"rrapply 1.2.4","text":"CRAN release: 2022-03-07 Fixed minor issue nested data.frames using classes = \"data.frame\" = \"recurse\" Removed deprecated arguments feverywhere dfaslist","code":""},{"path":"/news/index.html","id":"rrapply-123","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.3","title":"rrapply 1.2.3","text":"CRAN release: 2021-02-08 Fixed minor bug classes argument case missing f condition arguments","code":""},{"path":"/news/index.html","id":"rrapply-122","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.2","title":"rrapply 1.2.2","text":"CRAN release: 2021-01-25 Added new option = \"bind\" unnest nested list wide data.frame Options = \"flatten\", = \"melt\" = \"bind\" coerce flat lists common types Unnamed list elements receive names \"1\", \"2\", … .xname, .xparents, = \"melt\" = \"bind\" Added pokedex demo dataset Reorganized source code","code":""},{"path":"/news/index.html","id":"rrapply-121","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.1","title":"rrapply 1.2.1","text":"CRAN release: 2020-11-07 Arguments feverywhere dfaslist deprecated favor classes (instead use classes = \"list\" classes = \"data.frame\") Added option = \"recurse\" replace deprecated feverywhere = \"recurse\" Cleaned source code fixed several minor issues","code":""},{"path":"/news/index.html","id":"rrapply-120","dir":"Changelog","previous_headings":"","what":"rrapply 1.2.0","title":"rrapply 1.2.0","text":"CRAN release: 2020-10-12 Added support call objects expression vectors Added special argument .xsiblings evaluating sibling list f condition","code":""},{"path":"/news/index.html","id":"rrapply-111","dir":"Changelog","previous_headings":"","what":"rrapply 1.1.1","title":"rrapply 1.1.1","text":"Added new option = \"unmelt\" restore nested list melted data.frame Added special argument .xparents evaluating parent node vector f condition","code":""},{"path":"/news/index.html","id":"rrapply-110","dir":"Changelog","previous_headings":"","what":"rrapply 1.1.0","title":"rrapply 1.1.0","text":"CRAN release: 2020-07-04 Added new option = \"melt\" return melted data.frame pruned nested list Added options feverywhere = \"break\" list node aggregation feverywhere = \"recurse\" list node updating Cleaned source code fixed several minor issues","code":""}]
