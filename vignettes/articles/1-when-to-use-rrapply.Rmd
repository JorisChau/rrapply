---
title: "Efficient list recursion with rrapply"
author: "Joris Chau"
date: "Latest date: `r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: false
vignette: >
  %\VignetteIndexEntry{Efficient list recursion with rrapply}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, echo = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

# List recursion in R

The nested list below outlines the genealogy of several famous mathematicians. Each list element contains an additional `"given"` attribute with the mathematician's given name. The numeric values at the leaf elements are the total number of descendants according to the [Mathematics Genealogy Project](https://www.genealogy.math.ndsu.nodak.edu/) as of June 2020. If no descendants are available there is a missing value present at the leaf node. 

```{r}
students <- list(
  Bernoulli = structure(list(
    Bernoulli = structure(list(
      Bernoulli = structure(1, given = "Daniel"),
      Euler = structure(list(
        Euler = structure(NA, given = "Johann"),
        Lagrange = structure(list(
          Fourier = structure(68679, given = "Jean-Baptiste"), 
          Plana = structure(NA, given = "Giovanni"),
          Poisson = structure(113435, given = "Simeon")
        ), given = "Joseph")
      ), given = "Leonhard")
    ), given = "Johann"),
    Bernoulli = structure(NA, given = "Nikolaus")
  ), given = "Jacob")
)

str(students, give.attr = FALSE)
```

Consider the following exercise in list recursion: 

<div class="bs-callout bs-callout-primary">
  Filter all descendants of 'Leonhard Euler' while keeping the original list structure and replace all missing values by zero.
</div>

Here is a possible (not so efficient) solution using recursion with the `Recall()` function: 

```{r}
prune_replace_Euler <- function(x) {
  i <- 1
  while(i <= length(x)) {
    if(identical(names(x)[i], "Euler") & identical(attr(x[[i]], "given"), "Leonhard")) {
      x[[i]] <- rapply(x[[i]], f = function(x) replace(x, is.na(x), 0), how = "replace")
      i <- i + 1
    } else {
      if(is.list(x[[i]])) {
        val <- Recall(x[[i]])
        x[[i]] <- val
        i <- i + !is.null(val)
      } else {
        x[[i]] <- NULL
      }
      if(all(sapply(x, is.null))) {
        x <- NULL
      }
    }
  }
  return(x)
}

str(prune_replace_Euler(students), give.attr = FALSE)
```

This works, but is hardly the kind of code we would like to write for such a seemingly simple data exploration question. Moreover, this code is not very easy to follow or reason about, which makes it time-consuming to update or modify for future tasks.

Another approach would be to unnest the list in a more manageable (e.g. rectangular) format or use specialized packages such as [igraph](https://igraph.org/r/) or [data.tree](https://CRAN.R-project.org/package=data.tree) to make pruning or modifying node entries more straightforward. Note that attention must be payed to correctly include the node attributes in the transformed object as the node names themselves are not unique in the given example. This is a sensible approach for more complex data analysis or statistical modeling tasks, but ideally we would like to keep the list in its original format for simple data exploration to reduce the number of processing steps and minimize the possibility of introducing mistakes in the code.

The recursive function above makes use of `rapply()`, a member of the base-R **apply**-family of functions, that allows to apply a function recursively to the elements of a nested list and decide how the returned result is structured. If you are not familiar with the `rapply()` function it might be useful to first read the function documentation `help("rapply")` or check out the first section of the `rrapply`-package vignette (`browseVignettes(package = "rrapply")`).

Although quite useful, the `rapply()`-function is not always sufficiently flexible in practice, e.g. for pruning elements of a nested list (as demonstrated above). The `rrapply()` function is an attempt to enhance and update base `rapply()` to make it more generally applicable in the context of list recursion. The `rrapply()` function builds on the native implementation of base `rapply()` in R's C-interface and for this reason requires no other external dependencies. 

# When to use `rrapply()`

For illustration purposes, we will use the dataset `renewable_energy_by_country` included in the `rrapply`-package, a nested list containing the shares of renewable energy as a percentage in the total energy consumption per country in 2016. The data is publicly available at the United Nations Open SDG Data Hub [UNSD-SDG07](https://unstats-undesa.opendata.arcgis.com/datasets/indicator-7-2-1-renewable-energy-share-in-the-total-final-energy-consumption-percent-3). The 249 countries and areas are structured based on their geographical location according to the United Nations M49 standard [UNSD-M49](https://unstats.un.org/unsd/methodology/m49/) The numeric values listed for each country are percentages, if no data is available the value of the country is `NA`.

```{r}
library(rrapply)
data("renewable_energy_by_country")
```

For convenience, we subset only the values for countries and areas in Oceania,

```{r}
renewable_oceania <- renewable_energy_by_country[["World"]]["Oceania"]
str(renewable_oceania, list.len = 3, give.attr = FALSE)
```

## List pruning and unnesting

With base `rapply()`, there is no convenient way to prune or filter elements from the input list. The `rrapply()` function adds an option `how = "prune"` to prune all list elements not subject to application of the function `f` from a nested list. The original list structure is retained, similar to the non-pruned versions `how = "replace"` and `how = "list"`. 
Using `how = "prune"`, we can for instance drop all `NA` elements from the list while preserving the original list structure:

```{r}
## Drop all logical NA's while preserving list structure 
na_drop_oceania <- rrapply(
  renewable_oceania,
  f = identity,
  classes = "numeric",
  how = "prune"
)
str(na_drop_oceania, list.len = 3, give.attr = FALSE)
```

Instead, set `how = "flatten"` to return a flattened unnested version of the pruned list. This is more efficient than first returning the pruned list with `how = "prune"` and unlisting or flattening the list in a subsequent step. 

```{r}
## Drop all logical NA's and return unnested list
na_drop_oceania2 <- rrapply(
  renewable_oceania,
  f = identity,
  classes = "numeric",
  how = "flatten"
)
str(na_drop_oceania2, list.len = 10, give.attr = FALSE)
```

Or, use `how = "melt"` to return a melted data.frame of the pruned list similar in format to `reshape2::melt()` applied to a nested list. The rows of the melted data.frame contain the node paths of the elements in the pruned list. The `"value"` column is a list-column with the values of the terminal nodes analogous to the flattened list returned by `how = "flatten"`. 

```{r}
## Drop all logical NA's and return melted data.frame
na_drop_oceania3 <- rrapply(
  renewable_oceania,
  f = identity,
  classes = "numeric",
  how = "melt"
)
head(na_drop_oceania3)
```
If no names are present in a sublist of the input list, `how = "melt"` replaces the names in the melted data.frame by list element indices `"..1"`, `"..2"`, etc.:

```{r}
## Remove all names at L2 
## (skip this for now, these arguments are explained in the following sections)
oceania_unnamed <- rrapply(
  renewable_oceania,
  condition = function(x, .xpos) length(.xpos) < 2,
  f = unname,
  feverywhere = "break"
)

## Drop all logical NA's and return melted data.frame
na_drop_oceania4 <- rrapply(
  oceania_unnamed,
  f = identity,
  classes = "numeric",
  how = "melt"
)
head(na_drop_oceania4)
```

## Condition function

Base `rapply()` allows to apply a function `f` to list elements of certain types or classes via the `classes` argument. `rrapply()` generalizes this concept via the `condition` argument, which accepts any principal argument function to use as a condition or predicate to apply `f` to a subset of list elements. Conceptually, the `f` function is applied to all leaf elements for which the `condition` function exactly evaluates to `TRUE` similar to `isTRUE`. If the `condition` argument is missing, `f` is applied to all leaf elements. In combination with `how = "prune"`, the `condition` function provides additional flexibility in selecting and filtering elements from a nested list.
Using the `condition` argument, we can update the above function call to better reflect our purpose:

```{r}
## drop all NA elements using condition function
na_drop_oceania3 <- rrapply(
  renewable_oceania,
  condition = Negate(is.na),
  f = identity,
  how = "prune"
)
str(na_drop_oceania3, list.len = 3, give.attr = FALSE)
```

More interesting is to consider a `condition` that cannot also be defined using the `classes` argument. For instance, we can filter all countries with values that satisfy a certain numeric condition: 

```{r}
## filter all countries with values above 85%
renewable_energy_above_85 <- rrapply(
  renewable_energy_by_country, 
  condition = function(x) x > 85, 
  how = "prune"
)
str(renewable_energy_above_85, give.attr = FALSE)

## or by passing arguments to condition via ...
renewable_energy_equal_0 <- rrapply(
  renewable_energy_by_country, 
  condition = "==", 
  e2 = 0, 
  how = "prune"
)
str(renewable_energy_equal_0, give.attr = FALSE)
```

**Remark**: Note that the `NA` elements are not returned, as the `condition` function does not evaluate to `TRUE` for `NA` values. Also, the `f` argument is allowed to be missing, in which case no function is applied to the leaf elements.

As the `condition` function is a generalization of the `classes` argument to have more
flexible control of the predicate, it is also possible to use the `deflt` argument
together with `how = "list"` or `how = "unlist"` to set a default value to all
leaf elements for which the `condition` does not evaluate to `TRUE`:

```{r}
## replace all NA elements by zero
na_zero_oceania_list <- rrapply(
  renewable_oceania, 
  condition = Negate(is.na), 
  deflt = 0, 
  how = "list"
)
str(na_zero_oceania_list, list.len = 3, give.attr = FALSE)
```

To be consistent with base `rapply()`, the `deflt` argument can still only be used together with `how = "list"` or `how = "unlist"`. 

### Using the `...` argument

The first argument to `f` always evaluates to the content of the leaf element to which `f` is applied. Any further arguments (besides the special arguments `.xname` and `.xpos` discussed below) that are independent of the node content can be supplied via the `...` argument. Since `rrapply()` accepts a function in two of its arguments `f` and `condition`, any further arguments defined via the `...` also need to be defined as function arguments in **both** the `f` and `condition` function (if existing), even if they are not used in the function itself.

To clarify, consider the following example where we replace all `NA` elements by a value defined in a separate argument `newvalue`:

```{r}
## this is not ok!
tryCatch({
  rrapply(
    renewable_oceania, 
    condition = is.na, 
    f = function(x, newvalue) newvalue, 
    newvalue = 0, 
    how = "replace"
  )
}, error = function(error) error$message)

## this is ok
na_zero_oceania_replace3 <- rrapply(
  renewable_oceania, 
  condition = function(x, newvalue) is.na(x), 
  f = function(x, newvalue) newvalue, 
  newvalue = 0, 
  how = "replace"
)
str(na_zero_oceania_replace3, list.len = 3, give.attr = FALSE)
```

## Special arguments `.xname`, `.xpos`, `.xparents` and `.xsiblings`

In base `rapply()`, the `f` function only has access to the content of the list element under evaluation through its principal argument, and there is no convenient way to access its name or location in the nested list from inside the `f` function. This makes `rapply()` impractical if we want to apply a function `f` that relies on e.g. the name or position of a node as in the `students` example above. To overcome this limitation, `rrapply()` allows the use of the special arguments `.xname`, `.xpos`, `.xparents` and `.xsiblings` inside the `f` and `condition` functions (in addition to the principal function argument). `.xname` evaluates to the name of the list element, `.xpos` evaluates to the position of the element in the nested list structured as an integer vector, `.xparents` evaluates to a vector of all parent node names in the path to the current list element, and `.xsiblings` evaluates to the parent list containing the current list element and all of its direct siblings.

Using the `.xname` and `.xpos` arguments, we can transform or filter list elements based on their names or positions in the nested list:

```{r}
## apply a function using the name of the node
renewable_oceania_text <- rrapply(
  renewable_oceania,
  f = function(x, .xname) sprintf("Renewable energy in %s: %.2f%%", .xname, x),
  condition = Negate(is.na),
  how = "flatten"
)
str(renewable_oceania_text, list.len = 10)

## extract values based on country names
renewable_benelux <- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xname) .xname %in% c("Belgium", "Netherlands", "Luxembourg"),
  how = "prune"
)
str(renewable_benelux, give.attr = FALSE)
```

Knowing that Europe is located under the node `renewable_energy_by_country[[c(1, 5)]]`, we can filter all European countries with a renewable energy share above 50 percent by using the `.xpos` argument,

```{r}
## filter European countries with value above 50%
renewable_europe_above_50 <- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xpos) identical(head(.xpos, 2), c(1L, 5L)) & x > 50,
  how = "prune"
)
str(renewable_europe_above_50, give.attr = FALSE)
```

This can be done more conveniently using the `.xparents` argument, as this does not require us to look up the location of Europe in the list beforehand,

```{r}
## filter European countries with value above 50%
renewable_europe_above_50 <- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xparents) "Europe" %in% .xparents & x > 50,
  how = "prune"
)
str(renewable_europe_above_50, give.attr = FALSE)
```

Using the `.xpos` argument, we could look up the location of a particular country in the nested list,

```{r}
## look up position of Sweden in list
(xpos_sweden <- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xname) identical(.xname, "Sweden"),
  f = function(x, .xpos) .xpos,
  how = "flatten"
))
renewable_energy_by_country[[xpos_sweden$Sweden]]
```
Instead, using the `.xsiblings` argument we could look up the direct neighbors of a particular country in the nested list,

```{r}
## look up sibling countries of Sweden in list
siblings_sweden <- rrapply(
  renewable_energy_by_country,
  condition = function(x, .xsiblings) "Sweden" %in% names(.xsiblings),
  how = "flatten"
)
str(siblings_sweden, give.attr = FALSE)
```
We could also use the `.xpos` argument to determine the maximum depth of the list or the length of the longest sublist as follows,

```{r}
## maximum list depth
depth_all <- rrapply(
  renewable_energy_by_country, 
  f = function(x, .xpos) length(.xpos), 
  how = "unlist"
)
max(depth_all) 

## longest sublist length
sublist_count <- rrapply(
  renewable_energy_by_country, 
  f = function(x, .xpos) max(.xpos), 
  how = "unlist"
)
max(sublist_count)
```

## List node aggregation

By default, both base `rapply()` and `rrapply()` recurse into any list-like element. To override this behavior, we can set `feverywhere = "break"` to apply `f` to *any* element of the nested list (e.g. a sublist) that satisfies the `condition` and `classes` arguments. If the `condition` or `classes` arguments are not satisfied for a list-like element, `rrapply()` will recurse deeper into the sublist, apply the `f` function to the nodes that satisfy `condition` and `classes`, and so on.

This option is useful to calculate summary statistics across nodes or to look up the position of intermediate nodes in the nested list. To illustrate, we can return the mean and standard deviation of the renewable energy share in Europe as follows:

```{r}
## compute mean value of Europe
rrapply(
  renewable_energy_by_country,  
  condition = function(x, .xname) .xname == "Europe",
  f = function(x) list(
    mean = mean(unlist(x), na.rm = TRUE), 
    sd = sd(unlist(x), na.rm = TRUE)
  ),
  how = "flatten",
  feverywhere = "break"
)
```

**Remark**: Note that the principal `x` argument in the `f` function can evaluate to an entire sublist for the node satisfying the `condition`. For this reason, we first `unlist` the sublist before passing it to `mean` and `sd`.

We can use the `.xpos` argument to apply the `f` function only at specific locations or depths in the nested list. For instance, we could return the mean renewable energy shares for each continent by making use of the fact that the `.xpos` vector of each continent has length (i.e. depth) 2:

```{r}
## compute mean value of each continent
renewable_continent_summary <- rrapply(
  renewable_energy_by_country,  
  condition = function(x, .xpos) length(.xpos) == 2,
  f = function(x) mean(unlist(x), na.rm = TRUE),
  feverywhere = "break"
)

## Antarctica has a missing value
str(renewable_continent_summary, give.attr = FALSE)
```

## List node updating

If `feverywhere = "break"`, `rrapply()` will not recurse further into list-like elements after application of the `f` function. This makes it for instance impossible to recursively update the name of each element in the nested list, as `rrapply()` stops recursing after updating the first list layer. For this purpose, we can set `feverywhere = "recurse"` in which case `rrapply()` recurses further into any *updated* list-like element after application of the `f` function. In this context, the `condition` function should be interpreted as a passing criterion (i.e. the opposite of a stopping criterion). As long as the `condition` and `classes` arguments are satisfied, `rrapply()` will try to recurse further into any list-like elements.

Using `feverywhere = "recurse"`, we can recursively replace all names in the nested list by their M49-codes:

```{r}
## replace country names by M-49 codes
renewable_M49 <- rrapply(
  list(renewable_energy_by_country), 
  condition = is.list,
  f = function(x) {
    names(x) <- vapply(x, attr, character(1L), which = "M49-code")
    return(x)
  },
  feverywhere = "recurse"
)

str(renewable_M49[[1]], max.level = 3, list.len = 3, give.attr = FALSE)
```
**Remark**: Here we passed `list(renewable_energy_by_country)` to the call of `rrapply()` in order to start application of the `f` function at the level of the list `renewable_energy_by_country` itself, instead of starting at its list elements. 

## Miscellaneous

### Data.frames as lists

By default, `rrapply()` and `rapply()` recurse into all list-like objects. Since data.frames are list-like objects, the `f` function is applied to the individual columns instead of the data.frame object as a whole. To change this behavior, `rrapply()` includes a convenience argument `dfaslist`. If `dfaslist = TRUE`, `rrapply()` behaves the same as `rapply()` by recursing into the individual columns of a data.frame. If `dfaslist = FALSE`, the `f` and `condition` functions are applied directly to the data.frame object itself and not its columns. 
```{r}
## create a list of data.frames
oceania_df <- list(
  Oceania = lapply(
    renewable_oceania[["Oceania"]], 
    FUN = function(x) data.frame(
      Name = names(x), 
      value = unlist(x), 
      stringsAsFactors = FALSE
    )
  )
)

## this does not work!
tryCatch({
  rrapply(
    oceania_df,
    f = function(x) subset(x, !is.na(value)), ## filter NA-rows of data.frame
    how = "replace",
    dfaslist = TRUE
  )
}, error = function(error) error$message)

## this does work
rrapply(
  oceania_df,
  f = function(x) subset(x, !is.na(value)),
  how = "replace",
  dfaslist = FALSE
)
```

**Remark**: Note that the same result can also be obtained using `feverywhere = "break"` and checking that the list element under evaluation is a data.frame:

```{r, eval=FALSE}
rrapply(
  oceania_df,
  condition = function(x) class(x) == "data.frame",
  f = function(x) subset(x, !is.na(value)),
  how = "replace",
  feverywhere = "break"
)
```

Using the `dfaslist` argument better reflects our purpose and is also slightly more efficient as the class of the list element is checked directly analogous to the `classes` argument. 

#### List attributes

Base `rapply()` may produce different results when using `how = "replace"` or `how = "list"` when working with list attributes. The former preserves intermediate list attributes whereas the latter does not. To avoid unexpected behavior, `rrapply()` always preserves intermediate list attributes when using `how = "replace"`, `how = "list"` or `how = "prune"`.  If `how = "flatten"`, `how = "melt"` or `how = "unlist"` intermediate list attributes cannot be preserved as the result is no longer a nested list.

```{r}
## how = "list" now preserves all list attributes
na_drop_oceania_list_attr2 <- rrapply(
  renewable_oceania, 
  f = function(x) replace(x, is.na(x), 0), 
  how = "list"
)

str(na_drop_oceania_list_attr2, max.level = 2)

## how = "prune" also preserves list attributes
na_drop_oceania_attr <- rrapply(
  renewable_oceania, 
  condition = Negate(is.na), 
  how = "prune"
)
str(na_drop_oceania_attr, max.level = 2)
```

### Using `rrapply()` on data.frames

The `dfaslist` argument can be used to avoid recursing into the individual columns of a data.frame object. However, it can also be useful to exploit exactly this property of `rapply()`. A convenient way to apply a function to columns of a data.frame of a certain class is through the use of the `classes` argument in base `rapply()`.

For instance, suppose we wish to standardize all `numeric` columns in the `iris`
dataset by their sample mean and standard deviation:

```{r}
iris_standard <- rapply(iris, f = scale, classes = "numeric", how = "replace")
head(iris_standard)
```

Using the `condition` argument in `rrapply()`, we gain additional flexibility in selecting the columns to which `f` is applied. For instance, we can now easily apply the `f` function only to the `Sepal` columns using the `.xname` argument:

```{r}
iris_standard_sepal <- rrapply(
  iris,                    
  condition = function(x, .xname) grepl("Sepal", .xname), 
  f = scale
)
head(iris_standard_sepal)
```

Instead of *mutating* columns, we can also *transmute* columns (i.e. keeping only the columns to which `f` is applied) by setting `how = "prune"`: 

```{r}
iris_standard_transmute <- rrapply(
  iris, 
  f = scale, 
  classes = "numeric", 
  how = "prune"
)
head(iris_standard_transmute)
```

In order to *summarize* a set of selected columns, use `how = "flatten"` instead of `how = "prune"`, as the latter preserves list attributes --including data.frame dimensions-- which should not be kept. 

```{r}
## summarize columns with how = "flatten"
iris_standard_summarize <- rrapply(
  iris, 
  f = summary, 
  classes = "numeric", 
  how = "flatten"
)
iris_standard_summarize
```

# Conclusion

To conclude, let us return to the list recursion exercise in the first section. Using `rrapply()`, we can solve the task in a more readable and less error-prone fashion. A possible approach is to split up the question in two steps as follows:

```{r}
## look up the position of Euler (Leonhard)
xpos_Euler <- rrapply(
  students, 
  condition = function(x, .xname) .xname == "Euler" && attr(x, "given") == "Leonhard",
  f = function(x, .xpos) .xpos,
  feverywhere = "break",
  how = "flatten"
)[[1]]

xpos_Euler 

## filter descendants of Euler (Leonhard) and replace missing values by zero
students_Euler <- rrapply(
  students,
  condition = function(x, .xpos) identical(.xpos[seq_along(xpos_Euler)], xpos_Euler), 
  f = function(x) replace(x, is.na(x), 0),
  how = "prune"
)

str(students_Euler, give.attr = FALSE)
```

Knowing that Johann Euler is a descendant of Leonhard Euler, we can further simplify this into a single function call using the `.xparents` argument:

```{r}
## filter descendants of Euler (Leonhard) and replace missing values by zero
students_Euler <- rrapply(
  students,
  condition = function(x, .xparents) "Euler" %in% .xparents,
  f = function(x) replace(x, is.na(x), 0),
  how = "prune"
)

str(students_Euler, give.attr = FALSE)
```

For additional information and details check out the package vignette (`browseVignettes(package = "rapply")`). The package vignette also includes additional examples that might serve as useful inspiration for list recursion tasks in practice. 


